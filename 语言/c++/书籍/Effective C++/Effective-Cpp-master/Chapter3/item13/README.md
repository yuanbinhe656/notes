# 条款13：以对象管理资源
----------------

**1.保证资源总是被释放。**<br>
把资源放进对象内，我们便可依赖C++的“析构函数自动调用机制“确保资源被释放。

**2.智能指针。**<br>
标准程序库提供的auto_ptr，是个”类指针对象“，也就是所谓的”智能指针“，其析构函数自动对其所指对象调用delete。

**3.”以对象管理资源“的两个关键想法。**<br>
(1)获得资源后立刻放进管理对象内。<br>
(2)管理对象运用析构函数确保资源被释放。

**4.由于auto_ptr被销毁时会自动删除它所指之物，所以一定要注意别让多个auto_ptr同时指向同一对象。**<br>
auto_ptr有一个不寻常的性质：若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权。

**5.”引用计数型智慧指针“(RCSP)。**<br>
对于一些要求允许正常的复制行为的类，那么这些类不得使用auto_ptr。<br>
所谓RCSP也是个智能指针，持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。

**6.auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作。**<br>
这意味这在动态分配而得的array身上使用auto_ptr和tr1::shared_ptr是个馊主意。

## 请记住：
* 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。
* 两个常被使用的RAII class分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向null。

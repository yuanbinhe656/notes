# 条款27：尽量少做转型动作
-------------------

**1.旧式转型与新式转型。**<br>
```
// C风格转型动作
(T)expression // 将expression转型为T
// 函数风格转型动作
T(expression) // 将expression转型为T
// C++中四种新式转型
const_cast<T>(expression)
dynamic_cast<T>(expression)
reinterpret_cast<T>(expression)
static_cast<T>(expression)
```

**2.新式转型较受欢迎的原因。**<br>
第一，它们很容易在代码中被辨识出来，因而得以简化“找出类型系统在哪个地点被破坏”的过程。<br>
第二，各转型动作的目标越窄化，编译器越可能诊断出错误的运用。

**3.任何一个类型转换往往真的令编译器编译出运行期间执行的码。**<br>

**4.避免使用dynamic_cast的做法。**<br>
第一，使用容器并在其中存储直接指向derived class对象的指针（通常是指针），如此便消除了“通过base class接口处理对象”的需要。<br>
第二，通过base class接口处理“所有可能之各种派生类”，那就是在base class内提供virtual函数做你想对各个派生类做的事。

**5.绝对必须避免的一件事是所谓的“连串”dynamic_cast。**<br>

## 请记住：
* 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。
* 如果转型是必须的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码里。
* 宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。

C/C++中的内存对齐
================


1.sizeof的基本知识

sizeof并不是函数,而是关键字,使用方法如下:
	
	Type var_name; // int i;
	sizeof(Type)或者sizeof(var_name)或者sizeof varname


	// 以下大小和机器有关
	sizeof(char) == 1
	sizeof(short) == 2
	sizeof(int) == sizeof(float) == sizeof(long) == 4
	sizeof(double) == sizeof(long long) == 8
	sizeof(long double) == 12
	sizeof(T*) == 4 // 以32位的机器为例

sizeof(数组) == 数组长度 * sizeof(元素)

注意以下区别:

	char str[] = "hello"; // 共6个元素,字符串末尾有'\0'
	sizeof(str) == 6
	char* str1 = "hello"; // const char*转化成char*会有警告
	sizeof(str1) == 4; // sizeof(指针)为4


	int arr[100];
	int size = sizeof(arr) / sizeof(*arr); // size == 100, sizeof(arr) == 400


	sizeof(NULL) == 4; // NULL为空指针


2.内存对齐

A.定义:
>
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

B.原因:
>
各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。


3.结构体中的变量偏移量(VC为windows的编译器,gcc为linux的编译器)

A.	定义:结构体内的成员变量偏移量为该成员首地址距离结构体首地址的字节大小


4.内存对齐机制

A.	在VC下的基本类型:

		-	成员变量a的偏移量为sizeof(a)的倍数,即:
		-	char偏移量必须为sizeof(char)即1的倍数
		-	int偏移量必须为sizeof(int)即4的倍数
		-	float偏移量必须为sizeof(float)即4的倍数
		-	double偏移量必须为sizeof(double)即8的倍数
		-	short偏移量必须为sizeof(short)即2的倍数
		-	指针偏移量必须为sizeof(T*)即4的倍数

B.	在gcc下的基本类型:

		-	对于sizeof小于等于2的类型,char, short, bool等变量偏移量取sizeof(T)的倍数,即char取1的倍数,short取2的倍数
		-	对于sizeof大于2的类型,int, float, double, long double等均为4的倍数
		-	故gcc变量偏移量只可能是2或4的倍数
		-	注:上述的变量偏移量要求是x的倍数,则x称为该变量偏移量的对齐模数
		
C.	无论的VC下还是gcc下的复合类型(数组,struct等)均取组成成员中最大变量偏移的对齐模数为其对齐模数

D.	当变量的大小不能够满足变量偏移量时,需要补位
	
	eg1:
	struct A {
		double d;
 	 	char c;
  		int i;
	};
	

在VC下:
		
	d的变量偏移量为0, 0为sizeof(double)==8的倍速,为0倍,故不需要在前补位
	所以1~8个字节分配给double d
	c的变量偏移量为8(由于前面有double d),而8为sizeof(char) == 1的倍数,所以不需要补位
	所以第9个字节分配给char c
	i的变量偏移量为9,不为sizeof(int) == 4的倍数,补至为4的倍数,故补充10, 11, 12三位,使得i的变量偏移为12(为4的倍数)
	接下来,13 14 15 16四位分配给int i
	现在struct A使用了1-16这16个字节
	最后还需要检查struct A需不需要补位,需要使得sizeof(A)为成员内最大对齐模数的倍数,最大的对齐模数为double d为8,所以sizeof(A)需要是8的倍数,16刚好为8的倍数不需要为struct A补位
	所以在VC下,sizeof(A) == 16

	在gcc下:
	d的变量偏移量为0,0为4的倍数(因为sizeof(double) == 8 > 2,所以对齐模数取4),不需要补位
	所以1~8个字节分配给double d
	c的变量偏移量为8(由于前面有double d),而8为1(由于sizeof(char) <= 2,故对齐模数取sizeof(char) == 1)的倍数,所以不需要补位
	所以第9个字节分配给char c
	i的变量偏移量为9,不为4的倍数(sizeof(int) > 2,取4),补至为4的倍数,故补充10, 11, 12三位,使得i的变量偏移为12(为4的倍数)
	接下来,13 14 15 16四位分配给int i
	现在struct A使用了1-16这16个字节
	最后还需要检查struct A需不需要补位,需要使得sizeof(A)为成员内最大对齐模数的倍数,最大的对齐模数为double d为4,所以sizeof(A)需要是4的倍数,16刚好为4的倍数不需要为struct A补位
	所以在gcc下sizeof(A) == 16


	eg2:
	struct A {
	  double d;
	  char c;
	  int i;
	};
	struct B {
	  int i;
	  char c;
	  A a;
	  char* cp;
	  char ca[10];
	}
	求sizeof(B)
	在VC下:
	1 2 3 4 分配给i (偏移量为0, 为4的倍数, 不用补位)
	5 分配给c (偏移量为4, 为1的倍数, 不用补位)
	6 7 8 补位 (由于a为复合类型,其成员最大对齐模数为8,随意它的偏移量需要为8的倍数)
	9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 分配给a
	25 26 27 28 分配给cp (cp的偏移量为24是4的倍数,不用补位)
	29 30 31 32 33 34 35 36 37 38 分配给ca (由于ca为复合类型,其成员char的对齐模数为1,其偏移量为28是1的倍数不用补位)
	先struct B大小为38其成员的最大对齐模数为8(A的对齐模数为8),所以需要补至40位才为8的倍数
	所以sizeof(B) == 40
	在gcc下:
	1 2 3 4 分配给i (偏移量为0, 为4的倍数, 不用补位)
	5 分配给c (偏移量为4, 为1的倍数, 不用补位)
	6 7 8 补位 (由于a为复合类型,其成员最大对齐模数为4,随意它的偏移量需要为4的倍数)
	9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 分配给a
	25 26 27 28 分配给cp (cp的偏移量为24是4的倍数,不用补位)
	29 30 31 32 33 34 35 36 37 38 分配给ca (由于ca为复合类型,其成员char的对齐模数为1,其偏移量为28是1的倍数不用补位)
	先struct B大小为38其成员的最大对齐模数为4(A的对齐模数为4),所以需要补至40位才为4的倍数
	所以sizeof(B) == 40
	注意:以上VC和gcc下sizeof相等只是巧合


5.设置对齐模数

	使用宏函数#pragma pack(n) // 将对齐模数设置为n,当一个变量的对齐模数小于等于n时,保持其默认对齐模数,当大于n时,对齐模数使用n
	另外#pragma pack(push)为保存对齐模数,#pragma pack(pop)为恢复对齐模数,#pragma pack()恢复默认对齐模数
	注意n只能取1 2 4 8
	eg:
	#pragma pack(2)
	struct S1 {
	    char a;
    	long b;
	};
	struct S2 {
	    char c;
 	   struct S1 d;
 	   long long e;
	};

	#pragma pack()
	VC下:
	在S1中
	1 分配给a
	2 补位 (long对齐模数为4大于2,故取2)
	3 4 5 6 分配给b
	6为2(最大模数成员b的模数2)的倍数,不用补位
	所以sizeof(S1) == 6
	在S2中:
	1 分配给c
	2 补位(S1对齐模数为2)
	3 4 5 6 7 8 分配给d
	9 10 11 12 13 14 15 16 分配给e(long long对齐模数大于2,取2,偏移量为8是2的倍数)
	此时S2大小为16是2倍数,不用补位置所以sizeof(S2) == 16
	在gcc下:
	情况类似
	sizeof(S2)也为16
	
	
	6.union
	union也是一种复合类型,也遵循复合类型取对齐模数的规则
	eg:
	union A {
	  int i;
	  char c;
	  double d;
	  char ca[10];
	};
	VC下:
	在A中
	1 2 3 4 分配给i (偏移量为0, 为4的倍数)
	1 分配给c  (偏移量为0, 为1的倍数)
	1 2 3 4 5 6 7 8 分配给d(偏移量为0, 为8的倍数)
	1 2 3 4 5 6 7 8 9 10 分配给ca(偏移量为0, 为1的倍数)
	此时A大小为10不为8的倍数,补至16位
	A的对齐模数为8
	
	7.注意:
	A.空结构体的sizeof为1,因为最小的对齐模数为1
	B.class的大小基本和struct一直,但是如果成员中或者基类成员中含有虚函数需要在计算后加上1个指针的大小
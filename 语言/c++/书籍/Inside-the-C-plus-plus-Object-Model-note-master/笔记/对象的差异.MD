#对象的差异
c++程序设计直接支持三种程序设计范式

###程序模型
就像 c 一样。字符串处理就是一个例子，我们 可以使用字符数组以及 str* 函数族群

###抽象数据类型模型
####抽象数据类型
	
	指一个数学模型以及定义在此数学模型上的一组操作
	
抽象数据类型是与表示无关的数据类型，对一个抽象数据类型进行定义时，必须给出它的名字与各运算的运算符。就像 string，我们可以通过 + , =, == 来进行操作

###面向对象模型
在此模型中有一些彼此相关的类型，通过一个抽象的 base class (用以提供共同接口)被封装起来。面向对象以对象为单位，每个对象包含对象的属性和方法，具有类和继承等特点

	class Library_materials { ... };
	class Book : public Library_materials { ... };
	
	Book book;
	Library_materials thing1 = book; // ADT, 此时 book 被切割了，thing1 
									 //只保存了一个 Library_materials 对象的内容
	Library_materials &thing2 = book; // 面向对象，此时是多态
	
在面向对象模型中，程序员需要处理一个未知实例，它的类型虽然有所界定，却有无穷可能。这组类型受限于其继承体系，然而该体系理论上没有深度和广度的限制。
	
原则上，被指定的 object 的真实类型在每个特定执行点之前，是无法解析的。在 c++ 中，只有通过 pointers 和 reference 的操作才能完成。相反，在 ADT 中，程序员处理的是一个拥有固定而单一类型的实例，它在编译时期就已经完全定义好了。

多态的用途主要是经由一个类型的接口来影响类型的封装，这个接口通常被定义在一个抽象的 base class 中。这个共享接口是以 virtual function 机制引发的，他可以在执行期根据 object 的真正类型解析出到底哪一个函数实例被调用。

###多少内存才能够表现一个 class object
- 其 non-static data member 的总和大小
- 加上任何由于 alignment 的需求而填补上去的空间【对齐】
- 加上为了支持 virtual 而由内部产生的任何额外负担

###指针的类型
以内存需求的观点来说，指向不同类型对象的指针没有什么不同。它们都需要足够的内存来存放一个机器地址。“指向不同类型之间各指针”间的差异，既不在其指针表示法的不同，也不在其内容不同，而是在其所寻址出来的 object 的不同。也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及大小。

那么，一个指向地址 1000 而类型为 void* 的指针，我们将不知道它会涵盖怎样的地址空间，因此一个类型为 viod* 的指针只能够持有一个地址，而不能够通过它操纵所指之 object。

`所以，转换 (cast) 其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和它的内容”的解释方式。`

##加上多态后
对一下代码：

	class A {
	public:
		virtual void fun() {}
		...
	};
	class B : public A { 
	public:
		virtual void fun() {}
		... 
	};
	B b;
	A a = b; // 这里会引起sliced
	a.fun(); // 调用 A 的fun

问题一：为什么 fun() 调用的是 A 的实例而不是 B 的实例？

`因为 a 并不是一个 B 的对象，它是(而且只能是)一个 A 对象。多态所造成的“一个以上的类型”的潜在力量，并不能够发挥在“直接存取 object”这件事上`

问题二：如果初始化函数讲一个 object 内容完整拷贝到另一个 object 中去，为什么 a 的 vptr 不能指向 b 的 virtual table？

`编译器在初始化及指定(也就是赋值)操作之间做出了仲裁。编译器必须确保如果某个 object 含有一个或者一个以上的 vptrs，那些 vptrs 的内容不会被 base class object 初始化或者改变`

当一个 base class object 被直接初始化为（或被指定为）一个 devided class object 时，devided class 就会被切割以塞入较小的 base type 内存中，devided、 type 将没有留下任何痕迹。

总而言之，多态是一种威力强大的设计机制，允许你继承一个抽象的 public 接口之后，封装相关的类型。需要付出的代价就是额外的间接性——不论是在“内存的获得”或是在“类型的决断”上。C++通过 class 的 pointer 和 reference 来支持多态。这种程序设计风格就成为 “面向对象”。

C++也支持 ADT 程序风格，如今被称为 object-base(OB)。例如 string class，一种非多态的数据类型。String class 可以展示封装的非多态形式：它提供一个 public 接口和 一个 private 实现品，包括数据和算法，但是不支持类型的扩充。

一个 OB 设计可能比一个对等的 OO 设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译使其解析完成，对象建构起来不需要设置 virtual 机制。空间紧凑则是因为每一个 class object 不需要负担传统上为了支持 virtual 机制而需要的额外负荷。但是， OO 比 OB 更有弹性。
A& & 变成 A&
 A& && 变成 A&
 A&& & 变成 A&
 A&& && 变成 A&&

就是左值引用会传染，只有纯右值&& && = &&，沾上一个左值引用就变左值引用了

引用折叠的规则上面的各位已经说得很清楚了，我在这里补充下引用折叠是为什么出现的吧。

要说引用折叠，首先得说右值引用(**在看这个之前需要了解C++11中左值，右值的概念**)。它是C++11出现的新概念，声明类型的方法是：T&&，具体信息可以看下面的代码：

```cpp
Class A

{
    A()
   {// do something}

};

A GetA()

{
    return A();
}

int main()
{

    A a1 = GetA();   // a1是左值
    A&& a2 = GetA(); // a2是右值引用
    return 0;
}
```

a1是左值，在构造时使用了GetA() 产生的临时对象，之后GetA()产生的临时对象会销毁。

a2是右值引用，其指向的就是GetA()所产生的对象，这个对象的声明周期是和a2的声明周期是一致的。即少了临时对象，从而省去了临时对象的构造和析构。

由此可见右值引用的好处，在新代码中，右值引用是值得大力使用的。但是，在使用的时候，**有例外情况了:T&&并不是一定表示右值，比如，如果它绑定的类型是未知的话，既可能是左值，又可能是右值。**比如：

```cpp
template<typename T>

void f(T&& param);

f(10); // 10是右值

int x = 10;
f(x);  // x是左值
```

以上这种未定的引用类型(param的类型)称为 universal references,这种类型必须被初始化,而它是左值还是右值则取决于它的初始化，如果被左值初始化，那么它就是左值，反之亦然。那么什么时候是左值，什么时候是右值，就需要进行**类型推导**才知道。

**由于存在T&&这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这是经过类型推导的T&&类型，相比右值引用(&&)会发生类型的变化，这种变化就称为引用折叠。**（《深入应用C++11-代码优化与工程级应用》 --- 祁宇 P68 ）

引用折叠的规则如下（配合@[jun-jun](https://www.zhihu.com/people/wang-jun-3)的答案）[和上一段的出处一样]：
1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
2.所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）
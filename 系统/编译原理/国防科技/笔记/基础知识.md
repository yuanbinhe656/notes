本文内容主要参考国防科技大学[编译原理](https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020)慕课课程（链接：[国防科大慕课地址](https://www.icourse163.org/course/NUDT-1003101005?from=searchPage)  
王挺老师所讲内容基本和华科计院编译原理课程内容一致，这也是我自己边学习边做的一些笔记，为了防止丢失，特意上传上来，学弟学妹们也可以参考复习。如有疏漏之处还望各为敬请斧正!

# 第一章 引论

## 1.1 编译过程和编译程序的结构

![image-20210624173029337](res/基础知识/24c174560d67758d702a05e44e31bbf3.png)

## 1.2 编译程序结构中的前端和后端划分的意义

```
编译过程的阶段是一种逻辑上的划分。在具体设计和实现上，可以重新组织系统模块结构。 
（1）划分“前端/后端”。将与仅依赖于源程序而与目标机器（硬件）无关的阶段组合成前端，将与目标机器（硬件）相关的阶段组合成后端。 
使得程序员不必考虑机器的细节，独立于机器。
```

![image-20210624173248099](res/基础知识/55973c7df49e0d535b30dc2d36e02e0d.png)

## 1.3 编译与解释的区别

```
编译方式是先翻译后执行，即将整个源程序翻译完毕，再执行目标程序，只需要保存完整的目标程序而无需保存源程序。一次翻译后无需再翻译，可多次执行。
解释方式是边翻译边执行，即翻译一句就执行一句，翻译完毕也执行完毕，只保存源程序无需保存完整的目标程序。执行一次需要翻译一次。 
```

**编译程序和解释程序的存储组织有很大不同**

```
编译程序处理时,在源语言程序被编译阶段,存储区中要为源程序(中间形式)和目标代码开辟空间,要存放编译用的各种各样表格,比如符号表.在目标代码运行阶段,存储区中主要是目标代码和数据,编译所用的任何信息都不再需要.
解释程序一般是把源程序一条语句一条语句的进行语法分析,转换为一种内部表示形式,存放在源程序区,比如BASIC解释程序,将LET和GOTO这样的关键字表示为一个字节的操作码,标识符用其在符号表的入口位置表示.因为解释程序允许在执行用户程序时修改用户程序,这就要求源程序,符号表等内容始终存放在存储区中,并且存放格式要设计的易于使用和修改.
```

![image-20210624173804711](res/基础知识/90174962df533f2c08054da41764af0c.png)

![image-20210624173818715](res/基础知识/15ef6987ef05196a08782804b168e534.png)

# 第二章 文法和语言

```
2.1 右线性文法（正则文法、3 型文法）;
2.2 构造右线性文法生成给定的语言；
2.3 规范推导，句柄。
```

## 2.1 文法类型

对规则构成加以限制，可以将文法的分类为四种类型：0型文法、1型文法、2型文法和3型文法。

![image-20210625111922315](res/基础知识/46ebc6140fc0efe5c9fbd7ddab69c42a.png)

![image-20210625111941734](res/基础知识/375682fe67e79d465d25e960e940db4f.png)

![image-20210625111956201](res/基础知识/80b9df8ef955ef05995dd5d7e4b918a4.png)

![image-20210625112037674](res/基础知识/ff8e9982fd6876d734f51bbe78bd277c.png)

![image-20210625112100591](res/基础知识/1cfd69bbfe3d3c4b554369f5a8789df2.png)

![image-20210625112133096](res/基础知识/33cf6d019955af291868f2bbfd7c9baf.png)

例题：

<img src="res/基础知识/image-20230226190028131.png" alt="image-20230226190028131" style="zoom:50%;" />

## 2.2 上下无关文法及其语法树

上下无关文法一个显著特征是规则左部一定有且仅有一个非终结符。

如果在推导的每一步总是选择当前句型的最左（最右）边非终结符进行推导，则称这种推导过程为最左（最右）推导。

最右推导，也叫规范推导。由规范推导所得的句型，叫做规范句型。规范推导的逆过程，叫做规范归约。

![image-20210625112414680](res/基础知识/9b1b02706bdcd43e37c0617e00f54b77.png)

![image-20210625112456972](res/基础知识/6d8d8d30c9d643f7d5038a52c47593a6.png)

## 2.3短语 直解短语 句柄



![image-20210619131014855](res/基础知识/8bf2618a6fae3bee0047b061fb38cee3.png)

![image-20210619131029323](res/基础知识/f3bd2f79fcc83411cca8dde81c27874f.png)

其中最下一层可以是非终结符，非终结符可以构成短语，而短语只能由最底下的叶子节点将短语进行表示

## 2.4例题

构造产生如下语言的上下文无关文法各一个：如图中（2）（5）（6）

![image-20210626205044016](res/基础知识/13b4699389b34fe478ffeb03c29c925e.png)

![image-20210626205057191](res/基础知识/1e2e87143d0590420c9f250f18949048.png)

```
(2）G[S]: S -> aS | aSb | ε 
(5）G[S]: S -> aSbb | aSbbb | ε
(6）G[S]: S -> aSa | bSb | ε
```

给出生成下述语言的一个3型文法：如图中的（2）

![image-20210626205504607](res/基础知识/050a9b5e622d0418d098cdd867b73ce7.png)

```
G[S]:
S -> aS | aB
B -> bB | b
```

# 第三章 词法分析

```
3.1 正则表达式；
3.2 把正则表达式转换成等价的 NFA；
3.3 将 NFA 转换成等价的 DFA(子集法)；
3.4 DFA 的最小化(分割法);
3.5 给定 DFA，写出其等价的右线性文法。
```

## 3.1 正则表达式

![image-20210624195538770](res/基础知识/9c84b367bb1e15dd25bdfe6e03ef88b0.png)

![image-20210624195551799](res/基础知识/583be671ee1eb0e0447bf0a6ae88646a.png)

![image-20210624195609612](res/基础知识/c9c185760dc53c91b6f9111993ae7bff.png)

## 3.2 正则式与正规文法的转换

### 3.2.1 正则式转正规文法

![image-20210626155659208](res/基础知识/0a6c63e666f450a1d379c213a947f76f.png)

对于正规式，规则1,2,3是一个过程，多次对其进行该过程化简，最终仅含一个终结符的文法便是正规文法

左线性文法就是从

### 3.2.2 正规文法转正规式

![image-20210626155723871](res/基础知识/64dc8e99da7565e6f1f40a6bb5c3b782.png)

主要是进行合并操作

## 3.2 NFA与DFA基本知识

### 3.2.1 DFA(确定的有穷自动机)

![image-20210624195720594](res/基础知识/bc2c7e0e77ee2e6575d7ca4c63f21f0e.png)

```
转换函数f可以扩充为f′: K×Σ*→K映射，并以f替代f′使用。
```

![image-20210624195808656](res/基础知识/5ded945e8d31973eadd83a729fac175e.png)

![image-20210624195846148](res/基础知识/15d2afb22b9630e3b13bfdb155c94338.png)

### 3.2.2 NFA(不确定的有穷自动机)

![image-20210624195931010](res/基础知识/9bac819b42f9e1adfffc9d0025a3574f.png)

![image-20210624195953707](res/基础知识/ebc7379a650fbfeb29880fb26b752f75.png)

```
NFA转换函数f也可以扩充为f′: ρ(K)×Σ*→ρ(K)映射，并以f替代f′使用。
```

**扩充函数用法举例：**

![image-20210624200046660](res/基础知识/708e1ac8c7ad680e78bb7c930d08b223.png)

![image-20210624200322903](res/基础知识/dbd5ff4da695a1a86133c9afc40c32f5.png)

**NFA的可接受串：**

![image-20210624200109411](res/基础知识/ef390d393794a22e75ed02ea1846285f.png)

![image-20210624200121574](res/基础知识/792b6e530259ff078f7faac991d6047d.png)

### 3.2.3 自动机的等价性

![image-20210624200155289](res/基础知识/8e987e30fd86e6673117232923e23e63.png)

### 3.2.4 ε闭包运算

![image-20210624200511846](res/基础知识/98ee8307f5b56a1d58bf12810507fbf6.png)

![image-20210624200520349](res/基础知识/0e5682055815a088d4c32ef8cf8ae9d7.png)

## 3.3 将 NFA 转换成等价的 DFA(子集法)

![image-20210624200707717](res/基础知识/304347100d3ca8a3ee938710f9a2649a.png)

![image-20210624200722178](res/基础知识/5b8aa293f7f1776e3f4c50996cd32afa.png)

![image-20210624200730993](res/基础知识/7080215092a872449af8dcd1cb8103ab.png)

## 3.4 DFA 的最小化(分割法)

![image-20210624201808438](res/基础知识/83ca68064ac65182f43de52995b0a487.png)

```
修正：步骤③中M({3,4},a)={1,4}。
```

### NFA到DFA转化步骤

1. NFA-> DFA

   1. 将初态和终态设置均新增一个，使其成为真正的，分别将原先的与新增的连接起来
   2. 若nfa中存在经过ab达到另一个状态，则新增一个中间态
   3. 生成
      1. 闭包：一个状态通过一条ϵ弧到达的状态集，则是其闭包
      2. 从初态开始，先对初态做闭包运算
      3. 该集合接受一个终结符生成的集合
      4. 生成的集合做闭包填入其初态闭包的对应终结符状态集
      5. 依次操作，最后可将集合用数字将其表示，形成新的状态
   4. 化简
      1. 区分两个状态集：若两个状态同时接受任意一个a均能到达其终态，则这两个状态等价
      2. 分别将其分为终态和非终态，从非终态开始，其接受一个终结符，看其生产的状态集是否出现不同的状态，若出现不同的状态，则代表其存在不同的状态，将其按接受终结符后的状态区分不同的状态集
      3. 依次进行，最终生成的状态集中的状态均是等价的，其可以任选一个作为该状态集的代表

2. 习题：

   1. ![image-20230312231703944](res/基础知识/image-20230312231703944.png)

   2. ![image-20230312231811513](res/基础知识/image-20230312231811513.png)

      



## 3.5 正规式与NFA转换

### 3.5.1 NFA到正规式

![image-20210624202406919](res/基础知识/3e82a4e8d0f7e1e355690896ff7e49e4.png)

![image-20210624202509086](res/基础知识/e7a0023545c87202d3bacf5b44eb1f75.png)

### 3.5.2 正规式到NFA

![image-20210624202613701](res/基础知识/4d8cc0987d6a2f8c1c66cafbc1b5a932.png)

![image-20210624202629333](res/基础知识/1066dc7942ca6aec09f50180c8d19c73.png)

![image-20210624202755613](res/基础知识/d2a8717f2c835ea51a32ed30ff3a4879.png)

## 3.6 正规文法和有穷自动机间的转换

### 3.6.1 右线性正规文法到NFA

![image-20210624203011259](res/基础知识/30f724894785047d863310948c97bee8.png)

![image-20210624203055456](res/基础知识/b3444753549408d822ae56e8f9c716f9.png)

![image-20210624203103991](res/基础知识/5fff9a228e3e9006dbe68ca6f3e4e433.png)

### 3.6.2 左线性正规文法到NFA

![image-20210624203232937](res/基础知识/d53c59b9aaa06f3a426ad94309a92327.png)

![image-20210624203323943](res/基础知识/b93e531176c11303a2452fd1b0f815a5.png)

![image-20210624203423124](res/基础知识/302ef986c04ffe4b7c5bc0b1dfe01310.png)

### 3.6.3 DFA到右线性正规文法

![image-20210624203609476](res/基础知识/31bbedd399095f938b4274319a77ac75.png)

![image-20210624203616791](res/基础知识/61d7c604aeea432bceea6d322daf677b.png)

## 3.7 总结

如果想要将**正则式转换为正规文法**，可以采取以下步骤：

正则式-》NFA-》DFA-》右线性正规文法

如果想要将**正规文法转换为正则式**，可以采取以下步骤：

正规文法-》NFA-》DFA-》正则式

# 第四章 自顶向下语法分析方法

```
4.1 如何判断文法是 LL(1)的；4.2 构造 LL(1)的分析表；4.3 分析给定的句子，是否是符合该 LL(1)文法的句子。详细描述分析的过程，包括栈，分析串的变化过程，每一步采用的产生式，或分析的结论（终结符匹配出栈，出错，接受等）。
```

## 4.1 自上而下分析的基本问题

### 4.1.1 语法分析基本概念

![image-20210617195911571](res/基础知识/65f29e13a963bb1f9e8d0327b5826e65.png)

![image-20210617195928319](res/基础知识/dd1fdc9b41c644c8575bd85a330ec5fd.png)

![image-20210617200010553](res/基础知识/fa81c27047a352ed3dacb1dcc3f61a06.png)

![image-20210617200059643](res/基础知识/455a9b674dbf03165d5c1ec6e78f4318.png)

![image-20210617200145342](res/基础知识/c8ee56cca449817b827b4ad74e3cde0e.png)

![image-20210617200212103](res/基础知识/978c4e4c5847cca713ece1de020fa897.png)

![image-20210617200239051](res/基础知识/cb37716f2d0ea32339e03e453d6fc779.png)

![image-20210617200253607](res/基础知识/be0b6b6ff443c3e133737029b250664b.png)

### 4.1.2 自上而下分析面临的问题

#### 4.1.2.1回溯问题

![image-20210617200409873](res/基础知识/c011a820255d1219c726fc03464e819a.png)

![image-20210617200539093](res/基础知识/4fa04421c7ef6e8daf92d50d6a18a099.png)

![image-20210617200555464](res/基础知识/dbe31fdf5e63800838e4a9e294122504.png)

![image-20210617200615487](res/基础知识/efea7056f5820283f719b5757256fcbc.png)

```
此时的A有两个产生式，那么到底选择哪一个呢？需要逐个试一下,先试试第一个产生式
```

![image-20210617200717642](res/基础知识/4e76262d53ed428b1b72961578b83a09.png)

![image-20210617200726906](res/基础知识/80d87e0a7cc2094f43c7bc88e8682390.png)

```
此时两个箭头都指向非终结符，但两个非终结符不同，说明A的产生式选择错误，需要重新选择，也就是产生了回溯。
```

![image-20210617200821740](res/基础知识/ff89cbd290583a402e44905ddfeda0c0.png)

![image-20210617200828305](res/基础知识/7ebebb5a5d1d90b70e53d9a82d0317d2.png)

```
此时A选择了第二个产生式
```

![image-20210617200846095](res/基础知识/415a74a70ba220013614ef2f3aef3f2a.png)

```
匹配成功。可以看出上述回溯是因为A有多个产生式，但不知道要选择哪一个产生的
```

![image-20210617200947089](res/基础知识/125df4f7e42ed44435b295278276d20d.png)

#### 4.1.2.2文法左递归问题

![image-20210617201055083](res/基础知识/8df1c123d838d012b25aaa7cb0b7f5a2.png)

```
因为自上而下推导采用最左推导法，这样就会导致产生死循环。
```

## 4.2 LL(1)文法——消除文法左递归

### 4.2.1 消除直接左递归

![image-20210617201332474](res/基础知识/b8aec9f373e080af14a0167372cbf87f.png)

```
一般情况如下：
```

![image-20210617201423851](res/基础知识/b624dae47868b85453981af36adfdd66.png)

```
根据原产生式可知，P是由β1,2,..n 中的一个开头且随后是α1,2,..m中的一个或多个组成的串
```

**例题：**

![image-20210617201915399](res/基础知识/cab9fd3bb22343a134477ae3b8b5089c.png)

### 4.2.2 消除间接左递归

![image-20210617201952034](res/基础知识/15d32a497f1f3807cf8e61226263cfd6.png)

![image-20210617202106653](res/基础知识/78fb8c312b176444ad72d1bc1dfb6997.png)

```
以上两个条件容易满足：1.对于一个上下文无关文法来说，如果语言本身不含ε，那么总可以给出不含ε的文法2.没有消除左递归之前可以有左递归，但不能自己推出自己。
```

![image-20210617202349532](res/基础知识/b53c8d08ae5d3572af454a870c86709b.png)

```
具体做法：将各个非终结符拍个序起名叫LIST。然后按照顺序逐个考查产生式（这个顺序是指，假如LIST={R,Q,S}，那么首先要考查左侧是R的产生式，再考查左侧是Q的产生式），如果当前产生式右侧的非终结符B与产生式左侧非终结符A相比，如果在LIST中B排在A的后面，那么就需要把B给替换掉。消除完间接左递归后如果产生直接左递归那么还应该继续消除。然后再查看是否有冗余的产生式。总结：最后达到的效果是：对于产生式A→Bβ（β是终结符）,那么在LIST中，A也排在B的左侧。
```

![image-20210617202502946](res/基础知识/eda9f6683bd6f32a60c00910d2d9a691.png)

![image-20210617204041984](res/基础知识/9f03120f31ec2f7b61219fd854431ace.png)

```
LIST={R,Q,S}那么首先要考查左侧是R的产生式，再考查左侧是Q的产生式，在考查左侧是S的产生式。
```

![image-20210617204253624](res/基础知识/2df7a0fae80a17ecebeb1cc278a24aa5.png)

## 4.3 LL(1)文法——消除回溯

![image-20210617205254301](res/基础知识/461034249dc17fabedd885c66153e076.png)

### 4.3.1 FIRST集合

1. 定义

![image-20210617205354184](res/基础知识/46c410f0ef32cc30f21f1e70ef50e240.png)

![image-20210617205430236](res/基础知识/135e00c2d949b5f6838591fb13f5c4e5.png)

```
假如非终结符的候选首符集有相交的，那么就需要提取公共左公因子
```

![image-20210617210242612](res/基础知识/f9fb51b38d6fcf5cc9c1dcd0188d6f29.png)

![image-20210617210353625](res/基础知识/cd29433406bd05570fb5f7b0d25740d2.png)

![image-20210617210406295](res/基础知识/efc67eaa20cdca0a8791f13350b9e28c.png)

```
在分析T‘时，由于T'的第一个产生式的FIST集为*，不能和+匹配，所以将T'匹配成了ε。
```

![image-20210617210617867](res/基础知识/e7ab0686541a9fb882b8261fb56b2061.png)

```
非终结符T'后面可能出现+，所以可以将T'匹配成ε，由此引出FOLLOW集合
```

### 4.3.2 FOLLOW集合

![image-20210617210810571](res/基础知识/dc2baae102685b4fa17ce038bf94154b.png)

### 4.2.3 LL(1)文法

![image-20210617211012240](res/基础知识/e16a3c638a927e9dc6e08dffd276f1fa.png)

```
第三条涉及到SELECT集的概念
```

![image-20210617211107592](res/基础知识/ea5a165ced9323bf956a4c272e4a0f2c.png)

## 4.4 FIRST和FOLLOW集合的构造

![image-20210617211136098](res/基础知识/39528dfa8b40357282d48b608c781bcb.png)

```
注意观察，FIRST集说的是α的FIRST集,FOLLOW集说的是非终结符的FOLLOW集
```

### 4.4.1 构造FIRST(α)

![image-20210617211336686](res/基础知识/e514ac50daf87123f4cb75add683eb24.png)

![image-20210617211554238](res/基础知识/0da31b7d83ef8a682d19649f12b4b59d.png)

![image-20210617211600778](res/基础知识/78907c4adf0bd87c74514f714da53185.png)

![image-20210617211649414](res/基础知识/57de0a84b277baa18bfa86fdefa859e2.png)

```
构造FIRST集合时，首先应该构造单个文法符号的FIRST集（终结符和非终结符）构造完单个文法符号的FIRST集合后才可以更方便的构造由单个文法符号组合而成的符号串的FIRST集。
```

### 4.4.2 构造FOLLOW(A)

![image-20210617212003083](res/基础知识/c80a2bd24c073d1e5d59e46d062a8a56.png)

![image-20210617212115948](res/基础知识/01ac09b85ad6fedfff3c09884f573382.png)

**正确性证明：**

![image-20210617212224111](res/基础知识/d153bd841d64568fd97997e6ccfcf220.png)

![image-20210617212257006](res/基础知识/81cce49b92f8c5f6c96a282890a2f3e5.png)

### 4.4.3 例题

![image-20210617212358206](res/基础知识/540f9732abea3486ee89f0a31e0d4fad.png)

```
构造FIRST集时的方法：1.考查每个产生式，如果有产生式A->aB...或者A->ε的产生式时，将 a,ε加入FIRST(A)2.将第1步用到的产生式去掉（它们只能说明终结符a或者ε属于某个非终结符的FIRST集）3.逐个考查剩下来的产生式，形如A->XYZ，那么可以确定的是FIRST(X)\{ε}属于FIRST(A)；此时查看FIRST{X}。此时有三种情况：	1.FIRST(X)为空，那么直接跳过。	2.FIRST(X)中不为空，但没有ε。此时将FIRST(X)中的所有元素加入到FIRST(A)中。	3.FIRST(X)中不为空，且有ε。此时将FIRST(X)中除了ε的所有元素加入到FIRST(A)中。然后再以同样的方法考查FIRST(Y)。	如果X,Y,Z的FIRST集合中都包含ε，那么此时再将ε加入到FIRST(A)中。4.如果有任何一个非终结符的FIRST集合有变动，都要重复3，直到没有变动。
```

```
构造FOLLOW集时的方法：1.首先构造各个非终结符的FIRST集。2.将#加入到S的FOLLOW集合中。3.逐个考查产生式：	1.A→α B β（β由非终结符和终结符组成），将FIRST(β)\{ε}，加入FOLLOW(B)中。如果FIRST(β)中含有ε,那么再将FOLLOW(A)中的元素加入到FOLLOW(B)中。	2.A→αB，则直接将FOLLOW(A)加入到FOLLOW(B)中。4.重复上述3，知道各个非终结符的FOLLOW集不再发生变化为止。
```

## 4.5 构造递归下降分析器

### 4.5.1 简介

![image-20210618104903487](res/基础知识/ac4446ee5411fbadf57f158713a237aa.png)

![image-20210618104942028](res/基础知识/bd5cfffefea99c2912ac48f98892eca2.png)

![image-20210618105013364](res/基础知识/0a9196e224a43ef73b3d7db4ca829313.png)

![image-20210618105112304](res/基础知识/3fccefa056cd24949350bc05f3ee28e9.png)

### 4.5.2 例题

![image-20210618105154370](res/基础知识/6470b9bebb5047035022a6c0bbf51c80.png)

E’有两种写法：

![image-20210618105853238](res/基础知识/2b262aad6126bc9ad8d02678bee0a80e.png)

![image-20210618105837721](res/基础知识/f9f14be7c0223e9cbdc88c74b7464e0f.png)

![image-20210618105847060](res/基础知识/d1ad2d8cb6a5010cddf6a7b97967110a.png)

```
第二种虽然没有考虑到E'的FOLLOW集，但这么写也是没问题的。因为每个非终结符的FOLLOW集最终都是来自于非终结符的FIRST集。若输入字符匹配不上所有的非空产生式时，直接将非终结符匹配为空串，那么若输入字符∉FOLLOW(E')时，在后续检查中总会出错。
```

![image-20210618110242589](res/基础知识/90ae41344791a903c6e009fd17e84e0c.png)

![image-20210618110714863](res/基础知识/be4240a5e53b0ca6f4f30c029f9dc516.png)

![image-20210618110723708](res/基础知识/dbf67bfbeed66f44ed90a3306f14f62c.png)

![image-20210618110731042](res/基础知识/e56128e55e3e1a95acda4941712c5a87.png)

## 4.6 扩充的巴克斯范式和语法图

![image-20210618110506361](res/基础知识/ebfa582dce1717504602b1ac4f0fc55f.png)

![image-20210618110515808](res/基础知识/13911a44e81fa2b9d1da71bc57f8c2a6.png)

![image-20210618110601294](res/基础知识/0abcb1b251d3d4523e1fbc9390959c93.png)

## 4.7 预测分析程序

### 4.7.1回顾LL(1)分析法

![image-20210618111249800](res/基础知识/b603d743d63e25f3b211dfc8325a6968.png)

### 4.7.2 预测分析程序的工作原理

![image-20210618111431118](res/基础知识/0d75d999b440f630e68e1b0f397d2232.png)

![image-20210618111614860](https://img-blog.csdnimg.cn/img_convert/393ec5646cd5375b427c2c777a69abca.png)

![image-20210618111624473](res/基础知识/9ae0dba68f1a2428a8c2128a38455624.png)

![image-20210618111855661](res/基础知识/cc4389ce6b70e464be2ced0d41fcdc95.png)

![image-20210618111906379](res/基础知识/affdd5e17b76220bba98afd13ebf8176.png)

### 4.7.3 预测分析示例

![image-20210618111950069](res/基础知识/5074c4677299251d339611f7c3518b72.png)

| 步骤 | 符号栈   | 输入串  | 产生式    |
| ---- | -------- | ------- | --------- |
| 1    | #E       | I\*I+I# | E->TE’    |
| 2    | #E’T     | I\*I+I# | T->FT’    |
| 3    | #E’T’F   | I\*I+I# | F->I      |
| 4    | #E’T’I   | I\*I+I# |           |
| 5    | #E’T’    | \*I+I#  | T’->\*FT’ |
| 6    | #E’T’F\* | \*I+I#  |           |
| 7    | #E’T’F   | I+I#    | F->I      |
| 8    | #E’T’I   | I+I#    |           |
| 9    | #E’T’    | +I#     | T’->ε     |
| 10   | #E’      | +I#     | E’->+TE’  |
| 11   | #E’T+    | +I#     |           |
| 12   | #E’T     | I#      | T->FT’    |
| 13   | #E’T’F   | I#      | F->I      |
| 14   | #E’T’I   | I#      |           |
| 15   | #E’T’    | #       | T’->ε     |
| 16   | #E’      | #       | E’->ε     |
| 17   | #        | #       | ACCEPT    |

## 4.8 预测分析表的构造

### 4.8.1 构造预测分析表

![image-20210618113027060](res/基础知识/44fa02c99235b1a98758a9bdfcd98059.png)

![image-20210618113148056](res/基础知识/b02cdf1d4e2192994e6b37a9ba203552.png)

![image-20210618113306350](res/基础知识/74bb879cf9979821ba2da351796173bb.png)

![image-20210618113319046](res/基础知识/3c75ab91062e07f4653e855fffc06f53.png)

![image-20210618113547397](res/基础知识/1e53c7b3552a4b5f82e5a81e3714a49e.png)

### 4.8.2 LL(1）文法与二义性

![image-20210618113622651](res/基础知识/bc221b160fd9118c2826c2d2a64da9e4.png)

![image-20210618113813707](res/基础知识/6168bc7f089410b05f8eaaffb5a1d16f.png)

# 第五章 自下而上语法分析方法

```
5.1 算符优先分析算法基本思想，其中的重要概念。
```

## 5.1 自下而上分析

![image-20210618160419475](res/基础知识/bf6e13e929c1f7d00a69c6e65d0242ec.png)

![image-20210618160450916](res/基础知识/c3936d178f843ce2dc6ae03c32ecbf95.png)

![image-20210618160510614](res/基础知识/c4ee55791faf8974c88509d11059a829.png)

![image-20210618160625916](res/基础知识/ebb87559c21bb013e109b084a8098621.png)

![image-20210618160731715](https://img-blog.csdnimg.cn/img_convert/7ca822f1a7ea17370c535359d9fb529e.png)

## 5.2短语与直接短语

1. 短语的定义

![image-20210618160924026](res/基础知识/0abc0bcd89c8d9db80372e071bc2452b.png)

```
The teacher是相对于NP的一个短语对短语的理解最好结合语法树来理解
```

2. 直接短语的定义

![image-20210618161136099](res/基础知识/95ba71be196ba58466e835afbfe2cf27.png)

![image-20210618161357552](https://img-blog.csdnimg.cn/img_convert/a381a6b53f30c0155ece275085c60409.png)

```
短语为一个子树下面挂载的所有的根节点。直接短语为一个高度为2的子树下面挂载的所有根节点
```

## 5.3 分析过程描述

![image-20210618163225705](res/基础知识/c4c111466e4e5915e0dfbdb86521a416.png)

## 5.4 算法优先文法

### 5.4.1 概述

![image-20210618163338768](res/基础知识/e3f7c3e52a2d5e23ae99df36dc671cd5.png)

![image-20210618163414316](res/基础知识/b266eb5880aa4eae75fc36f5a64cc3ca.png)

### 5.4.2优先关系

![image-20210618163459051](res/基础知识/6a62de67e559840499d5ec5449bd0db6.png)

### 5.4.3 算符文法

![image-20210618163631455](res/基础知识/dd3a0748c6a41c2b7f4de10f568c1f52.png)

### 5.4.4 算符优先文法

```
对算符文法再加以限制
```

![image-20210618163757380](res/基础知识/af3260b50dfa0d7eb5566737a03dafe7.png)

![image-20210618164021159](res/基础知识/87cb984c8849d32ddc5a889e9fe0e792.png)

![image-20210618164033393](res/基础知识/dd995052fea990fa3b709eb468dcc11b.png)

![image-20210618164058767](https://img-blog.csdnimg.cn/img_convert/5a3f96f00d20b99d9c643f3db6d2a5c4.png)

![image-20210618164220823](res/基础知识/98032ff21c9bbbc34033c9f37afb1fe4.png)

```
怎么填这个表看下面的内容
```

## 5.5 构造优先关系表

### 5.5.1 FIRSTVT和LASTVT

![image-20210618164514748](res/基础知识/85b2c6d054dad1626dba719caf13b676.png)

![image-20210618164521786](res/基础知识/21bcad2de1ca32d60b47f3ce1f8ac2e5.png)

```
FIRSTVT(P)就是P能推出来的所有产生式中第一个终结符的集合。LASTVT(P)就是P能推出来的所有产生式中最后一个终结符的集合。
```

### 5.5.2 构造FIRSTVT和LASTVT算法

1. 构造算法

![image-20210618164840313](res/基础知识/3acdf6d2990e47ee4c2c6c09e8217a0a.png)

![image-20210618165159060](res/基础知识/993ef99aeaca3ff3fba121cf7497f7a9.png)

### 5.5.3 构造FIRSTVI,LASTVT举例

![image-20210618165234325](https://img-blog.csdnimg.cn/img_convert/d4d017942bdb5f1bd952a69719650e3e.png)

\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Q2e1lN0-1626245560537)(https://gitee.com/citianzhao/blogimg/raw/master/img/image-20210618165357407.png)\]

```
实操方法：1.首先逐个考查每个形如P->a...和P->Qa...的产生式，将a加入到FIRSTVT(P)2.逐个考查每个形如P->Q...的产生式，将目前FIRSTVT(Q)中的元素加入到FIRSTVT(P)中。3.如果任意一个非终结符的FIRSTVT有变化，都要重复做以便步骤2，直到没有变化为止。
```

![image-20210618165405175](res/基础知识/254f29236ac8668a0abc372e3c7902ef.png)

```
实操方法：1.首先逐个考查每个形如P->...a和P->...aQ的产生式，将a加入到LASTVT(P)2.逐个考查每个形如P->...Q的产生式，将目前LASTVT(Q)中的元素加入到LASTVT(P)中。3.如果任意一个非终结符的LASTVT有变化，都要重复做以便步骤2，直到没有变化为止。
```

### 5.5.4 构造优先关系表的算法

![image-20210618170417353](res/基础知识/cde9866c5ebce8668aa449b2cede6225.png)

**注意：当讨论#的优先级时，只需要考查#E#即可：**  
**1.首先将=填入#和#对应的项中**  
**2.#<a ( a∈FIRSTVT(E) )**  
**3.b># ( b∈LASTVT(E) )**

![image-20210618170446678](res/基础知识/eaa1bfb2c35c0a30e521a73c33975e75.png)

```
实操方法：与上述算法相同。表竖着的那一列代表左边的符号，横着的那一行代表右边的符号。因此对形如...aP...的候选式，可以将<填在a对应的那一行。对形如...Pa...的候选式，可以将>填在a对应的那一列。
```

## 5.6 算符优先分析算法

### 5.6.1 最左素短语

![image-20210618172509168](res/基础知识/e18ef8d477f190ffee97a536e8bde690.png)

![image-20210618172523486](res/基础知识/2c0d47f13679671517155e37b0476ec6.png)

### 5.6.2最左素短语定理

![image-20210618172758672](res/基础知识/cfa74226c0a09779093ee435c509c40f.png)

### 5.6.3 算符优先分析算法

![image-20210618173322574](res/基础知识/fcad9c4d7d8674ba0e873f93d836f917.png)

```
实操：1.将#移入STACK。2.比较最靠近栈顶的终结符a和当前串的第一个终结符b的优先级：	1.a<b,则将终结符b移入	2.a=b，则将终结符b移入	3.a>b，则自栈顶向栈底逐个寻找，找到一个串Njaj..NiaiNi+1能和一个产生式P->X1X2X3..Xn匹配上	（这里的匹配上指：对两个串的终结符来说，对应位置都相等；对两个串的非终结符来说，不必相等）3.知道栈中出现#N#时表示规约成功。
```

![image-20210618173809851](res/基础知识/604162cfca192075e7b3826af77f623b.png)

### 5.6.4 算符优先分析法举例

![image-20210618174014834](res/基础知识/9a9e432c43d32611953c42e1259919dc.png)

![image-20210618174137887](https://img-blog.csdnimg.cn/img_convert/9f6aeb0429a015033c9d0c7f1a0636bc.png)

![image-20210618174149336](res/基础知识/5b68f7f406d81efa859e9a5286362cb7.png)

![image-20210618174204698](https://img-blog.csdnimg.cn/img_convert/547e2df45e599606f0977d1919786c76.png)

![image-20210618174221731](res/基础知识/291206568a9b1c20349d610689e73094.png)

# 第六章LR分析

```
6.1 LR(1)项目集 LR(1)项目是一个二元组：[LR(0)项目，向前搜素符号集(前瞻符号集)]6.2 构造识别活前缀的 DFA6.3 构造 LR(1)分析表6.4 LR(1)分析算法
```

## 6.1 句柄和规范规约

![image-20210619130904225](res/基础知识/0b90fd29a799c58be61c3a565bd4a5df.png)

![image-20210619130921487](res/基础知识/dc8c471345a5bf612599e5e2b2535a92.png)

![img](res/基础知识.assets/image-20210619130934395.png)

### 6.1.1 短语、直接短语和句柄

![image-20210619131014855](res/基础知识/8bf2618a6fae3bee0047b061fb38cee3.png)

![image-20210619131029323](res/基础知识/f3bd2f79fcc83411cca8dde81c27874f.png)



![image-20210619131126136](res/基础知识/ecbeed0e9816517e3e00b1f67b463003.png)

### 6.1.2 规范规约

![image-20210619131202504](https://img-blog.csdnimg.cn/img_convert/8e1562c53a1040f6d8076123b131956d.png)

![image-20210619131224836](res/基础知识/e4019fabc479760ee0bb998304aa5716.png)

![image-20210619131332185](res/基础知识/01d13514f8f164c3a90aab34cfd45bf2.png)

![image-20210619131431664](res/基础知识/b7468c2b1f7f857aaebac1c3ee908253.png)

## 6.2LR分析法

### 6.2.1 概述

![image-20210619131545912](res/基础知识/fc6cff86e9eefae685e1cf38e91db69a.png)

![image-20210619131618580](res/基础知识/2efab73b8fa7866c2a49602d59457302.png)

### 6.2.2 LR分析表

![image-20210619131650728](res/基础知识/11097ce6cf140503a5912347056e0e53.png)

![image-20210619131735632](res/基础知识/f7b5f51d455a54cdc717788ce893b3a7.png)

![image-20210619131805422](res/基础知识/4eba2084e485859dd0afd612231ba3f9.png)

![image-20210619131814672](res/基础知识/c238aaaca3ac93569b6b4d9986d88cd5.png)

![image-20210619131831327](res/基础知识/26b0b803a1b6346a444ea9ee2a09505a.png)

### 6.2.3 LR分析过程

![image-20210619131935287](res/基础知识/eb55c6005af3c1733fb8f58b37a06196.png)

![image-20210619131954939](res/基础知识/86994d320ba0279c1474c02ed63d5f2f.png)

```
对第二种情况的说明：
```

![image-20210619132132453](res/基础知识/ecee0c006736b3f3ba272a31bd44bc19.png)

### 6.2.4 LR分析示例

![image-20210619133823605](res/基础知识/13be7b9b3f4b881c42bb2b26873df793.png)

![image-20210619134412995](res/基础知识/2a021e1967c473faacb3e4af7a5ef608.png)

![image-20210619132209608](res/基础知识/1aab463feb1cb7cad79c7cac0a088057.png)

| 步骤 | 状态    | 符号  | 输入串  |
| ---- | ------- | ----- | ------- |
| 1    | 0       | #     | I\*I+I# |
| 2    | 05      | #I    | \*I+I#  |
| 3    | 03      | #F    | \*I+I#  |
| 4    | 02      | #T    | \*I+I#  |
| 5    | 027     | #T\*  | I+I#    |
| 6    | 0275    | #T\*I | +I#     |
| 7    | 027(10) | #T\*F | +I#     |
| 8    | 02      | #T    | +I#     |
| 9    | 01      | #E    | +I#     |
| 10   | 016     | #E+   | I#      |
| 11   | 0165    | #E+I  | #       |
| 12   | 0163    | #E+F  | #       |
| 13   | 0169    | #E+T  | #       |
| 14   | 01      | #E    | #       |
| 15   | 接受    |       |         |

![image-20210619133433363](res/基础知识/f717d661a83f8e805f1ee27491206cfa.png)

```
构造分析树：1.当规约时分析树从下向上生长。2.当移入时，添加一个新的叶子结点
```

### 6.2.5 LR文法

![image-20210619133709302](res/基础知识/e0dcfdebac59d147c19e7b126de9362e.png)

![image-20210619133731994](res/基础知识/200abfc5f49d6297335e6b264dcc93d6.png)

## 6.3活前缀

### 6.3.1 字的前缀、活前缀

![image-20210619140559811](res/基础知识/e32b3aa607a96d675e3a13d08de21552.png)

![image-20210619140616430](res/基础知识/975d96a91292c598729d6cc6bfa354ae.png)

## 6.4 构造识别活前缀的DFA

### 6.4.1 LR(0)项目

![img](res/基础知识.assets/image-20210619140708592.png)

![img](res/基础知识.assets/image-20210619140808971.png)

![img](res/基础知识.assets/image-20210619140824800.png)

### 6.4.2通过构造NFA来构造识别所有活前缀的DFA（方法一）

![img](res/基础知识.assets/image-20210619141019162.png)![image-20210619141803025](res/基础知识/49c5e1699dd8130100503693ecb522ea.png)

```
按照前面学习的方法，将NFA转化成DFA
```

![image-20210619141936482](res/基础知识/a076b4abbb646fa09ba6ad9a19513340.png)

```
输入串bd#：1.从0状态接受b，转到3状态。2.从3状态接受d，转到11状态。3.11状态为规约项目，将d规约为B。栈顶弹出（11，d）,回退到3状态。4.将B压入栈中，3状态遇到B转移到7状态，因此将7压入栈中。此时栈顶为（7，B）5.7状态为规约项目，将b,B弹出，回到0状态。再将E压入栈中，状态0接受E，转为1状态。而1状态为接受项目，最终接受串bd#。
```

### 6.4.4 通过计算项目集规范族构造识别活前缀的DFA（方法二）

1. LR(0)项目集规范族

![image-20210619142733765](res/基础知识/f570188c98071d7eec4aebc56f037413.png)

2. 有效项目

![image-20210619143457839](res/基础知识/5e76e411d3f9590f6c66b245959a58f9.png)

```
A->β1.β2对活前缀αβ1有效，其条件是存在规范推导S'->αAw...注意，αAw，A前面的东西是αβ1减去A->β1.β2 ‘.’前面的东西得到的。
```

3. 有效项目的性质

![image-20210619143908252](res/基础知识/df25079402e32f135ab377b7b47110a2.png)

![image-20210619143936202](res/基础知识/309b068951d0048175f03db9eea8d58a.png)

**LR(0)项目集规范族的构造**

1.拓展文法

![image-20210619144003855](res/基础知识/8eee8fd26d9249b23ab2eae3a2835824.png)

2.计算项目集闭包

![image-20210619144036195](https://img-blog.csdnimg.cn/img_convert/599e609bf007ff8a4f2f8c36254cae44.png)

以下两个图帮助理解：

![image-20210619144142355](https://img-blog.csdnimg.cn/img_convert/94f22b609ef10799685c996ce52722dc.png)

![image-20210619144152285](https://img-blog.csdnimg.cn/img_convert/9bc83cf72121a08322cd3b555ea7b4dc.png)

3.计算状态转换函数

![image-20210619144409152](res/基础知识/e0364ef43252b23075c50f04d68d7540.png)

![image-20210619144424119](res/基础知识/15be5f7fcd9e2fbaaf60d38f615681f9.png)

状态转换函数计算示例：

![image-20210619144455919](res/基础知识/1fd21c3dd3f9c721d9cb6656e1f0ab98.png)

4.计算结果展示

![image-20210619144706389](res/基础知识/7a8871cc4f6a4aecddb150bb1a21010e.png)

```
具体实操：1.扩展文法2.首先计算CLOSE(S'-.S)作为状态03.对于每个新增的状态，对其中所有项目的GOTO函数，生成多个新状态。计算GOTO函数的方法见上面的描述。4.重复步骤2，直到不再产生新状态为止。
```

## 6.5 构造LR(0)分析表

### 6.5.1 LR(0)文法的一种定义

![image-20210619145233760](res/基础知识/31121ce40a18585938b998d7a6787208.png)

### 6.5.2 构造LR(0)分析表算法

![image-20210619145314999](res/基础知识/64e3d0489dabcec653cfdd6ec270156a.png)

![image-20210619145328239](res/基础知识/a2a7742d35f6fbf5b13568ba25509f55.png)

### 6.5.3 构造举例

![image-20210619145601925](res/基础知识/bb22e37ba45674098b70bd24df9a5a66.png)

![image-20210619145609935](res/基础知识/ad05a9588e111c3320e28acf93a73a61.png)

![image-20210619145619654](res/基础知识/275ad69cb631df8b72ea539e53283e09.png)

```
具体操作：按照编号顺序逐个考查每个项目集，项目集有三种情况：	1.项目集只含有移入项目：则从本项目集射出的边上如果是终结符就在ACTION的对应位置填上sx,如果是非终结符就在GOTO的对应位置上填入		x(x为这个射出的边指向的项目集的编号)。	2.项目集只含有接受项目：则在ACTION表中对应的行，#对应的列，填入acc	3.项目集只含有规约项目：则在ACTION表中对应的行，所有列填入rx（x是本项目对应的产生式的序号）
```

## 6.6 SLR(1)分析法

### 6.6.1 一个非LR(0)文法

![image-20210619165307421](res/基础知识/6929107f8db6749d5a41f983d9b61cd5.png)

![image-20210619165321810](res/基础知识/d3d51fa9265ff2ae15b6e232c27d5522.png)

![image-20210619165333693](res/基础知识/0d8f84fd77c2ae84e23b4fac5ec2a792.png)

```
此时就产生了移入规约冲突。就需要引入FOLLOW集合来考查到底是移入还是规约。只要拟移入项目.后面的符号不在可规约项目箭头左部符号的FOLLOW集中就不会发生冲突。
在该文法中，紧跟着A的一个终结符只可能在follow中，如果不在说明A还是不完整的，不应该规约成A
```

### 6.6.2 SLR(1)冲突解决办法

![image-20210619165620297](res/基础知识/2be7b7ceabeaa6ac70fdd407acfae07a.png)

**一般情况：**

![image-20210619165644609](res/基础知识/9ce8099a70394f79cf5046a88a17214b.png)

### 6.6.3 SLR(1)分析表的构造

![image-20210619165909755](res/基础知识/abb47ec4d1143cc8fcb90ff9d2f1fe99.png)

![image-20210619165958734](res/基础知识/45a918d4c8463bc1451ed42e6bef6075.png)

![image-20210619170041267](res/基础知识/279675076ae383137352a70c524d9f4b.png)

LR（0）相当于只要A能规约就立即规约，而不看其是否满足后续条件进行A规约，而SLR（0）则在满足follow（A）和（加入后续终结符能满足规约A的）终结符不相交的情况下进行区分

![image-20210619170054775](res/基础知识/32d1fa0642fc83e1e16cbc27991d2c87.png)

### 6.6.4 SLR(1)分析表构造示例

![image-20210619170122969](res/基础知识/0bc3ad097ca8b10e9fb59c53fcac8805.png)

![image-20210619170158378](res/基础知识/803ad385b22487fd0f60bd79784a7520.png)

![image-20210619170216516](res/基础知识/c40ae9e84e3a7c78e717c14efc70b80b.png)

![image-20210619170229375](res/基础知识/1bc63d6523f813c0543c68008297c2ed.png)

## 6.7 LR(1)分析法

### 6.7.1 一个非SLR(1)文法

![image-20210619171214986](res/基础知识/303386380445f018dd4f25755baabc26.png)

```
I2发生规约移入冲突。但是FOLLOW(R)={#，=}。因此当前输入串的第一个终结符为=时，就不知道是应该移入还是应该规约了。但是经过分析可以发现，非终结符R后面虽然可以接‘=’，但其只有在R前面为'*'时才出现。也就是说，如果R前面的终结符不是‘*’的话，R后面也就不可能出现‘=’了。
follow（A）将一些前缀不同的满足A的终结符都归入进去，可能会有一些前缀为x的匹配到前缀为Y的，此时对于前缀为X的A来说，其还未达到规约条件，造成混淆，需要对follow（A)进行进一步细分
```

![image-20210619171502975](res/基础知识/c130ed265788795d1c854c822217a500.png)

![image-20210619171557730](https://img-blog.csdnimg.cn/img_convert/f9868b8c7b8972315c1a70da9f774ed7.png)

### 6.7.2 LR(1)有效项目

**1.定义**

![image-20210619171838400](res/基础知识/8f28a7094dc3bbe2624ccc7440643ea9.png)

![image-20210619172114817](res/基础知识/53bc72770567a2a516bec5963616b110.png)

```
有效项目的意义：在形成A的过程中，α，已经形成。当形成β后，如果想要将αβ规约成A，那么当前输入字符串的首个终结符应该为a。
```

**2.性质**

![image-20210619173542226](res/基础知识/ae33d88b2e8ee587d6726e7e9dcaa211.png)

```
注：S=>*的第一次推导，a后面少一个w（w为非终结符）当希望ξ规约为B时，那么即将输入的字符串要么为β的开头；若β为空串时，即将输入的字符串应该为a。
```

**3.LR(1)项目集规范族**

![image-20210619174328162](res/基础知识/b8ff8b040c1853a7a8926441989db1cf.png)

```
与LR（0）求闭包的区别：1.LR(1)的项目后面还带有一个后缀。2.求形如(A->α.Bβ,a)的闭包时，LR(0)直接将所有的（B->.γ）项目纳入即可。而LR(1)不仅需要将所有的（B->.γ）项目纳入，还要在这些项目后面加上FIRST(βa)集合中的所有元素。
```

![image-20210619174401656](res/基础知识/1d4612e088219c328f1f4cdf83a1fa20.png)

![image-20210619174505902](res/基础知识/43b8f5af800aca500c4718ce6ba1d15d.png)

### 6.7.3 LR(1)分析表构造

![image-20210619175031861](res/基础知识/02621854b7cc9ae46a12a1484f43b160.png)

![image-20210619175038796](https://img-blog.csdnimg.cn/img_convert/404d076114e711b90b945b658a22a664.png)

![image-20210619175048336](https://img-blog.csdnimg.cn/img_convert/3fe766c0ba4969ed4f3e64b9c1d1e213.png)

```
填入规约方法时，填入的列相比而言更少了。
```

![image-20210619175125986](res/基础知识/0829289cb215d6c21e11a7217f0eebdd.png)

### 6.7.4 LR(1)分析表构造示例

![image-20210619175221389](https://img-blog.csdnimg.cn/img_convert/15084e01070f841f9bdf2d03d5c6f730.png)

![image-20210619175525887](https://img-blog.csdnimg.cn/img_convert/279652c7cd7541887abf34080e3d9e00.png)

# 第七章 语法制导的语义计算

## 7.1 属性文法

### 7.1.1 属性文法概念

![image-20210619195559479](https://img-blog.csdnimg.cn/img_convert/152a5c2327aa805a726aecd6735bd5cb.png)

**1.综合属性**

```
自下而上传递信息语法规则：根据右部候选式中的符号的属性计算左部被定义符号的综合属性语法树：根据子结点的属性和父结点自身的属性计算父节点的综合属性
```

![image-20210619195802461](https://img-blog.csdnimg.cn/img_convert/ebede4182086e1c12508556a2399edf5.png)

**2.继承属性**

```
自上而下传递信息语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的继承属性语法树：根据父结点和兄弟节点的属性计算子结点的继承属性
```

![image-20210619200053942](https://img-blog.csdnimg.cn/img_convert/3354d3d2d410bf3d943c67d27774bb22.png)

### 7.1.2 属性依赖

```
对应于每个产生式A→α都有一套与之相关联的语义规则，每条规则的形式为(f是一个函数)：b:=f(c1,c2,…,ck)。属性b依赖于属性c1,c2,…,ck1.b是A的一个综合属性并且c1,c2,…,ck是产生式右边文法符号的属性2.b是产生式右边某个文法符号的一个继承属性并且c1,c2,…,ck是A或产生式右边任何文法符号的属性
```

```
终结符只有综合属性，由词法分析器提供X F→digitX digit.lexval(digit的值，由词法分析器提供)
```

```
非终结符既可有综合属性也可有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值
```

**语义规则**

1. 对出现在产生式**右边的继承属性**和出现在产生式**左边的综合属性**都必须提供一个计算规则。属性计算规则中**只能使用相应产生式中的文法符号的属性**。

```
也就是说，产生式右侧的继承属性和产生式左侧的综合属性只能由本产生式计算得出，并且所使用的属性必须是本产生式中的文法的属性
```

2. 出现在产生式**左边的继承属性**和出现在产生式**右边的综合属性不由所给的产生式的属性计算规则进行计算**，由**其它产生式**的属性规则计算或者由属性计算器的参数提供。

例如：

![image-20210619201215345](https://img-blog.csdnimg.cn/img_convert/7b318874fc75b203b252acc0ff5b58a9.png)

```
L符号的in属性是L的一个继承属性。在产生式L→L1,id   L1.in :=L.in；addtype(id.entry, L.in)中，计算L1.in需要使用L.in，而L出现在产生式的左侧。因此L.in的值并非由本产生式得出，而是由D→TL   L.in := T.type 这个产生式提前计算出来。
```

**语义规则**所描述的工作可以包括**属性计算、静态语义检查、符号表操作、代码生成**等

![image-20210619201658823](https://img-blog.csdnimg.cn/img_convert/b16ecebcfada6a951ff559fd4e31a494.png)

### 7.1.3 带注释的语法树

![image-20210619201725319](https://img-blog.csdnimg.cn/img_convert/87092dd95a9f16cd8e1e52944d351e34.png)

![image-20210619201820286](https://img-blog.csdnimg.cn/img_convert/926a0e013117a4d5bb38d54c8ae47698.png)

![image-20210619201838373](https://img-blog.csdnimg.cn/img_convert/ffae3458572c05b00a1f84515f9b0521.png)

![image-20210619202044667](https://img-blog.csdnimg.cn/img_convert/40e961309efd1605cc01d04ad63aaee3.png)

![image-20210619202057401](https://img-blog.csdnimg.cn/img_convert/df4cd32a126ec7de1b2ed7fba4051d20.png)

```
id.entry是终结符的综合属性，由语法分析器给出。所以可以认为终结符的综合属性已知。
```

## 7.2 属性计算

### 7.2.1 属性计算

![image-20210619202410597](https://img-blog.csdnimg.cn/img_convert/058bb0c7f94e4df939820557238d8a3c.png)

![image-20210619202428218](https://img-blog.csdnimg.cn/img_convert/cfff7f7aea23987f7c17f5768acfc46e.png)

![image-20210619202439735](https://img-blog.csdnimg.cn/img_convert/4f4bfbb1c2fac35acb91f8e8c7fc0a35.png)

### 7.2.2 依赖图

![image-20210619202523747](https://img-blog.csdnimg.cn/img_convert/07bd4881b1c05214c52f9e8cea6a8cbe.png)

![image-20210619202547076](https://img-blog.csdnimg.cn/img_convert/63b562f91f4ad8f7b13a43f2a30cd097.png)

![image-20210619202944422](https://img-blog.csdnimg.cn/img_convert/294fa932fca3895d57387ed0b9bb7ce5.png)

```
每个节点的综合属性放在右侧，继承属性放在左侧。叶子结点如id,real的综合属性已知。id.entry指的是id在符号表中的index
```

![image-20210619202744458](https://img-blog.csdnimg.cn/img_convert/9f5d7fea649d38650545836b8fbfab1c.png)

![image-20210619202811559](https://img-blog.csdnimg.cn/img_convert/60936ad82f83273a2d21df8a9cc89449.png)

```
上面的那个依赖图的一个拓扑排序顺序为：1，2，3，4，5，7，6，8，9，10
```

### 7.2.3 树遍历算法

![image-20210619203153979](https://img-blog.csdnimg.cn/img_convert/724d77450d52bd84f54848023432dc76.png)

```c++
//树遍历算法while(还有未被计算的属性){    visitNode(s);//s为语法树的根节点}//总之就是先计算节点N的子树的根节点的继承属性，然后再遍历各个子树。遍历完子树后再计算当前节点的综合属性void visitNode(node N){    if(isVn(N))    {//n节点是一个非终结符,产生式为N->X1X2X3..Xm        for(int i=1;i<m;i++)        {            if(isVn(Xi))            {                //计算出Xi所有能够计算的继承属性                visitNode(Xi);            }        }        //计算出N所有能够计算的综合属性    }}
```

### 7.2.4 树遍历示例

![image-20210619203829333](https://img-blog.csdnimg.cn/img_convert/c338095ef52199e88b3718183f9656bb.png)

![image-20210619203838655](https://img-blog.csdnimg.cn/img_convert/61d2e5b7bfbc882237c0ffdf64dc25cd.png)

### 7.2.5 一遍扫描

![image-20210619204209258](https://img-blog.csdnimg.cn/img_convert/093e900e7f137bffa4b6d54d0754b33c.png)

![image-20210619204254840](https://img-blog.csdnimg.cn/img_convert/b0c1b094a0bcaca069c879cf26138b85.png)

![image-20210619204319149](https://img-blog.csdnimg.cn/img_convert/f194fd01a8cf93a865e693aaa53a820c.png)

![image-20210619204338593](https://img-blog.csdnimg.cn/img_convert/df2726fa280c68635866db37b033bb7b.png)

![image-20210619204430783](https://img-blog.csdnimg.cn/img_convert/aa877a69c6869e461d910b827cb4617b.png)

```
采用自下而上的分析方法
```

## 7.3 S-属性文法

![image-20210620112126677](https://img-blog.csdnimg.cn/img_convert/8585bc06cd0f5affdb24eb795608a2aa.png)

![image-20210620112209563](https://img-blog.csdnimg.cn/img_convert/32e768dd149423f0e3ba6f116e0e0f8a.png)

![image-20210620112402773](https://img-blog.csdnimg.cn/img_convert/60ceddd66d8e6724499f53da3ddbd799.png)

```
top指向规约前一刻的栈顶ntop指向规约后的栈顶
```

![image-20210620112603675](https://img-blog.csdnimg.cn/img_convert/670a26bb54686275a0db641254889419.png)

## 7.4 L-属性文法

L－属性文法适合一遍扫描的自上而下分析

![image-20210620112904591](https://img-blog.csdnimg.cn/img_convert/6d31fcfacf99609146b6e54b189780f4.png)

![image-20210620112947707](https://img-blog.csdnimg.cn/img_convert/e7e874cb15bb85f54c7cd20e87da28af.png)

![image-20210620113011695](https://img-blog.csdnimg.cn/img_convert/9367bf9600ed13ecbbe76b65bb9caa3c.png)

## 7.5 翻译模式

### 7.5.1 翻译模式

![image-20210620113110481](https://img-blog.csdnimg.cn/img_convert/0bc62e5ee49527dad578a65b1c3f4c9e.png)

![image-20210620113119913](https://img-blog.csdnimg.cn/img_convert/2456469ce87e7a56ceefdc924bfc3065.png)

![image-20210620113131660](https://img-blog.csdnimg.cn/img_convert/b5e27088984b57852136ab6a0e0d7c3a.png)

![image-20210620113137859](https://img-blog.csdnimg.cn/img_convert/f02e8bb3469e928836ce1f320dbc3a7f.png)

### 7.5.2 翻译模式示例

![image-20210620113503425](https://img-blog.csdnimg.cn/img_convert/f49b7615347c21e3715ec8a8c4c38206.png)

#### 7.5.2.1 设计翻译模式的原则

![image-20210620113532359](https://img-blog.csdnimg.cn/img_convert/346b116f1ee452018a74bc76c6cbd3b4.png)

#### 7.5.2.2 建立翻译模式

```
1.当只需要综合属性时：为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾
```

![image-20210620113930511](https://img-blog.csdnimg.cn/img_convert/df8ab7f7ff40c4d7cab5af1663252350.png)

```
如果既有综合属性又有继承属性，在建立翻译模式时就必须保证：1. 产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来2. 一个动作不能引用这个动作右边的符号的综合属性(因为此时还没有扩展其右侧符号，那么其右侧符号的综合属性一定不知道)3. 产生式左边非终结符的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的末尾
```

![image-20210620114409757](https://img-blog.csdnimg.cn/img_convert/84a17d0616d3291b6a220f53de44b949.png)

```
第一个翻译模式，A1A2的继承属性在最后计算；第二个翻译模式，A1的继承属性在A1扩展之前计算。计算时间的不同造成分析时的差异：
```

![image-20210620114455610](https://img-blog.csdnimg.cn/img_convert/c9e20eb7e5396a9e9853576e1d1c9f30.png)

#### 7.5.2.3 建立翻译模式示例

![image-20210620114639813](https://img-blog.csdnimg.cn/img_convert/7f69cd3f30917ea86e12d64b9e8b7ce9.png)

### 7.5.3 语义动作执行的时机统一

![image-20210620114816577](https://img-blog.csdnimg.cn/img_convert/51a788da998051bfa76a8d6b7e36d68b.png)

```
把所有的语义动作都放在产生式的末尾X 语义动作的执行时机统一转换方法X 加入新产生式M→εX 把嵌入在产生式中的每个语义动作用不同的非终结符M代替，并把这个动作放在产生式M→ε的末尾
```

![image-20210620114912245](https://img-blog.csdnimg.cn/img_convert/f5f8630796d6de4eb9398af0c3c156ed.png)

# 第八章 静态语义分析和中间代码生成

## 8.1 中间语言

![image-20210620152420024](https://img-blog.csdnimg.cn/img_convert/e6d74bc0b719f23974c06a473e4c6417.png)

## 8.2 常用的中间语言形式

![image-20210620152446889](https://img-blog.csdnimg.cn/img_convert/ab2141f733358c8cf1826f1bd100720d.png)

### 8.2.1 图表示法

![image-20210620152918423](https://img-blog.csdnimg.cn/img_convert/f8cc1c1ebc7bdda48edff74f7d7dee75.png)

![image-20210620153026127](https://img-blog.csdnimg.cn/img_convert/fa49047b070e1394a54d8ae24f9b4279.png)

![image-20210620153035678](https://img-blog.csdnimg.cn/img_convert/ff6f1304f282c92d21588f93847385c6.png)

![image-20210620153159512](https://img-blog.csdnimg.cn/img_convert/7e0904459dbc39863b00569cbdc381fd.png)

### 8.2.2 三地址语句

![image-20210620153238603](https://img-blog.csdnimg.cn/img_convert/f06aa1dcd4a44ccc0f197fbf61cc97d2.png)

![image-20210620153307181](https://img-blog.csdnimg.cn/img_convert/4eacca195e5fbc3e756a0fe1c592de78.png)

![image-20210620153438481](https://img-blog.csdnimg.cn/img_convert/a54a8d38132660ba7823cae40ec2bcf8.png)

![image-20210620153651901](https://img-blog.csdnimg.cn/img_convert/ecce6fac532e7c2fe37d3827a1cd191b.png)

#### 8.2.2.1 四元式

![image-20210620153744253](https://img-blog.csdnimg.cn/img_convert/d99f0342968dda293a7a7999154f0130.png)

```
与上面的三地址代码结合来看，result那一列填的是三地址代码'='左侧的符号。
```

#### 8.2.2.2 三元式

![image-20210620153820310](https://img-blog.csdnimg.cn/img_convert/de441746a993b5af9a526e898d08f5b6.png)

![image-20210620154245315](https://img-blog.csdnimg.cn/img_convert/373a65450118fafb6ba54f420417638f.png)

#### 8.2.2.3 间接三元式

![image-20210620154447631](https://img-blog.csdnimg.cn/img_convert/34259ff2a6a1de0f7865aa221848a759.png)

![image-20210620154520167](https://img-blog.csdnimg.cn/img_convert/361e8ead79cac6762dccbb03e4935237.png)

![image-20210620154650693](https://img-blog.csdnimg.cn/img_convert/fffa0332aa8012116a4522a46ba8082d.png)

## 8.3 赋值语句的翻译

### 8.3.1 赋值语句的属性文法

![image-20210620181737990](https://img-blog.csdnimg.cn/img_convert/e4454f965f26ee023593a9f011de8129.png)

![image-20210620181830312](https://img-blog.csdnimg.cn/img_convert/da09566bdcbf95af1a90c58ef2fbb951.png)

```
对.place属性的说明：这里的.place属性既可以指变量在符号表中存放的位置，又可以指变量的名字。因为可以根据变量的名字查找符号表找到变量存放的位置。因此在下面的叙述中对两种意思不再区分。
```

![image-20210620182001299](https://img-blog.csdnimg.cn/img_convert/5b9808d2b76b9c045d1336bb88700f3e.png)

```
一些说明：1.以上属性文法适合自下而上分析2.在将产生式右侧规约成左侧时，右侧的非终结符已经扩展完毕，也就是说右侧的非终结符的各个属性已知。3.函数gen（）表示根据传入的参数产生一个三地址代码。4.以上的.place既可以值变量在符号表中的位置，也可以指变量名。但作为gen()函数的参数时特指变量名。5.E.place=newtemp。可以理解为产生一个临时变量Tx，将该临时变量填入符号表，并返回这个临时变量在符号表中的位置。6.id是一个终结符，id的属性.place在进行分析时就已知。7.产生式如：E->E1*E2，进行的语义操作是将表达式E1,E2的语义值相乘，然后放到一个临时变量中去，然后将这个临时变量的位置赋值给E.place
```

### 8.3.2 赋值语句的翻译模式

赋值语句的S-属性文法见8.3.1，以下为其对应的翻译模式：

![image-20210620195711335](https://img-blog.csdnimg.cn/img_convert/0bb3baa8d41dc36cb1e9664fdc3817bb.png)

![image-20210620195740437](https://img-blog.csdnimg.cn/img_convert/45fe844e293740b7d46c960df8a7de5c.png)

```
说明：对第一个产生式来说：1.首先根据id.name属性从符号表中查找该变量，返回该变量存放的位置。如果返回为nil(空值)，则说明该变量未定义，直接报错。如果找到存放的位置，则将该位置赋值给p，产生一条三地址代码。此时假设p指向的变量名为a，E.place指向的变量名为T1，那么emit函数将向文件中输出一条‘a:=T1’的代码。2.在将id:=E规约为S时，E已经完成规约，也就是说E对应的三地址代码已经输出到了文件中，所以根据属性文法，此时只需要输出一条赋值三地址代码即可。
```

![image-20210620200326938](https://img-blog.csdnimg.cn/img_convert/9cef9e8baf497f3eea0c0eb33e3a3cb8.png)

## 8.4 数组元素引用的翻译

### 8.4.1 数组元素地址的计算规则

![image-20210620200419381](https://img-blog.csdnimg.cn/img_convert/b2eed80122deb7f251ce79d8d8832b9d.png)

![image-20210620200435540](https://img-blog.csdnimg.cn/img_convert/432c55fd92e64a894034d2969eae1901.png)

```c++
数组地址转换公式的说明：1.当数组下标是从0开始时，不变部分就成了base。2.可变部分随下标的改变而改变，需要在使用数组时计算。3.不变部分在处理数组声明语句时就可算出。4.如何计算可变部分：设数组访问为a[i1,i2,i3,i4..im]，可变部分为offset。计算步骤如下：    int offset=i1;	for(int k=2;k<=m;k++)    {        offset=offset*nk+ik    }3.计算不变部分步骤相似，只不过吧ik换成了lowk。
```

### 8.4.2 数组的文法

![image-20210620201826867](https://img-blog.csdnimg.cn/img_convert/38a031ecdd3137599f679a9f42683b55.png)

```
第一种语法不适合对数组进行自下而上的规约处理，因此改成了第二种，在对数组进行规约时，可以从左到右的读取数组的下标列表，方便计算可变部分。
```

![image-20210620202042044](https://img-blog.csdnimg.cn/img_convert/3086a61e4b1e11e6ef2e139bc787eaac.png)

![image-20210620202140937](https://img-blog.csdnimg.cn/img_convert/a9338bbb75da375491db39aab2866787.png)

### 8.4.3 带数组元素引用的赋值语句

![image-20210620202256303](https://img-blog.csdnimg.cn/img_convert/bf58c6a4f955420a482b2abe8b150b96.png)

### 8.4.4 带数组元素引用的赋值语句翻译模式

**适合自下而上的分析：**

![image-20210620202445646](https://img-blog.csdnimg.cn/img_convert/a90fbfde19b0a140df399e46349ada19.png)

```
假设存放数组不变部分的变量名为a，存放可变部分的变量名为T1,E.place对应的变量名为T2那么产生的三地址代码为：a[T1]：=T2。如果生成三元式的话，需要生成两行（见8.2.2.2）
```

![image-20210620202834399](https://img-blog.csdnimg.cn/img_convert/8448973da2509d606dc505e23868afde.png)

```
如果L是简单变量的话，那么此时L已经完成规约，只需要将L.place赋值给E.place即可。如果L是数组引用，那么此时需要生成一个临时变量，用于存放数组所引用的值。然后生成一条赋值三地址代码。为什么L是简单变量就不需要新生成临时变量呢？因为如果L是简单变量，则对应产生式L->id。变量id.name已经填入了符号表，规约时只要进行L.place=id.place即可。而如果L是数组引用，那么对应的那个变量并没有被填入符号表，所以需要产生一个临时变量用于保存所引用的值。
```

![image-20210620204006978](https://img-blog.csdnimg.cn/img_convert/7ad8e44d51b2cf06b86cc559b217f70f.png)

```
数组名的符号表中存放着本数组的基址（知道了id.place就知道了本数组的base）
```

![image-20210620204241889](https://img-blog.csdnimg.cn/img_convert/17d60cbd3976ac581852a894d99107ed.png)

```
假设当前处理数组引用的第m维
```

![image-20210620204441734](https://img-blog.csdnimg.cn/img_convert/1dd012e14b1a93e6b4c8716632b7717e.png)

## 8.5 类型转换

![image-20210620204611934](https://img-blog.csdnimg.cn/img_convert/6df78428d554f111145729d191f34a8f.png)

![image-20210620204636632](https://img-blog.csdnimg.cn/img_convert/2d1c2a901f7c8dcaca889729fc01c83e.png)

![image-20210620204708656](https://img-blog.csdnimg.cn/img_convert/025aecb8c2217f9a34c03f91c37347bc.png)

![image-20210620204739135](https://img-blog.csdnimg.cn/img_convert/4bb6c572ca9255928502b2f7f8757af3.png)

## 8.6 布尔表达式及其计算

![image-20210622195050030](https://img-blog.csdnimg.cn/img_convert/02338d9b12bd4513d0139d54c9377d4d.png)

![image-20210622195106288](https://img-blog.csdnimg.cn/img_convert/8d0d962da1c0eb38f766e77d300b67f2.png)

![image-20210622195202005](https://img-blog.csdnimg.cn/img_convert/f6faf4b32f5e902f4527bd35a476f86d.png)

## 8.7 按数值表示法翻译布尔表达式

```
只需要考虑 E.place和E.code属性
```

![image-20210622195424823](https://img-blog.csdnimg.cn/img_convert/6649b2280633970ed67ed26720bfee2f.png)

![image-20210622195543349](https://img-blog.csdnimg.cn/img_convert/c37b5934de8a2a4a2de4e28b19653205.png)

![image-20210622195617768](https://img-blog.csdnimg.cn/img_convert/3be84631b4acb04dfb6a5f47ab4e36cc.png)

![image-20210622195701353](https://img-blog.csdnimg.cn/img_convert/71c2f8dc0c395ae112fc5297df7999a1.png)

**解释：**

![image-20210622195726250](https://img-blog.csdnimg.cn/img_convert/40dd13b791735491ca81d7952ff6fcca.png)

```
1.采用自下而上的顺序分析，当考虑将E1,E2规约为E时，E1,E2的属性已经生成。E1.code，E2.code也已经输出到了文件中，所以只需要产生一条赋值代码即可。2.在规约之前，nextstat指向①的位置，产生赋值代码后nextstat指向②的位置。
```

![image-20210622200007986](https://img-blog.csdnimg.cn/img_convert/7ae7fe10ca0bc12d5680f1a470f2e1fb.png)

```
解释：E->(E1)进行这项规约时，E1的代码已经产生，且E1的计算结果已经存放在E1.place指向的变量中。所以规约后E只需接管E1.place指向的变量即可。（因为在自下而上的分析中，规约完E1后，符号E1及其属性是要弹出栈外的）
```

![image-20210622200307966](https://img-blog.csdnimg.cn/img_convert/0006a88b934c0f32975711f8d5d43b3b.png)

![image-20210622200407312](https://img-blog.csdnimg.cn/img_convert/9057a72b9a6467bbbdea2713e8c64539.png)

## 8.8 带优化翻译布尔表达式

### 8.8.1 带优化的翻译

注意：以下带有优化的翻译指**作为条件控制的布尔式**翻译

```
为了便于翻译，给布尔表达式E引入两个属性：1.E.true：指布尔表达式结果为true时程序要跳转的地址。也即S1翻译生成的三地址代码的首址。2.E.false:指布尔表达式结果为false时程序要跳转的地址。也即S2翻译生成的三地址代码的首址。给语句S引入了一个属性：S.next:指语句S执行后，下一个要执行的语句的首地址。
```

![image-20210622201326104](https://img-blog.csdnimg.cn/img_convert/4e480abaffe9ef6ae4bf8c4d84926ad0.png)

![image-20210622201804360](https://img-blog.csdnimg.cn/img_convert/0b652f432eaa02c5ce8ec74d8447fda7.png)

```
蓝色部分对应E翻译的代码；红色部分对应S1翻译的代码；绿色部分对应S2翻译的代码。蓝色部分E的翻译方式是经过优化的翻译方式。不经过优化的翻译方式翻译E代码的结果为：
```

| 地址 | 三地址代码      |
| ---- | --------------- |
| 100  | if a>c goto 103 |
| 101  | T1=0            |
| 102  | goto 104        |
| 103  | T1=1            |
| 104  | if b<d goto 107 |
| 105  | T2=0            |
| 106  | goto 108        |
| 107  | T2=1            |
| 108  | T3=T1 or T2     |

### 8.8.2 布尔表达式的属性文法

```
只需要考虑E.true,E.false,E.code属性
```

![image-20210622202326274](https://img-blog.csdnimg.cn/img_convert/abf9cabdfb89e932ee5fb05af11f59bb.png)

```
E.true和E.false为继承属性E.code为综合属性
```

![image-20210622202950067](https://img-blog.csdnimg.cn/img_convert/b229e6dd13a9727392910408a672574d.png)

```
对以上属性文法的解释：1.E.true,E.false因为为继承属性，出现在->左边。所以E.true和E.false在进行规约时是事先知道的。2.newlabel相当于产生一个‘L1:’的标号。方便跳转。3.E1为真，那么应该跳去整个表达式为真时要去的地方；E1为假，那么应该跳去E2产生的代码处做进一步判断。4.E2为真，那么应该跳去整个表达式为真时要去的地方；E2为假，那么应该跳去整个表达式为假时要去的地方。5.gen(E1.false:)是在E2产生的代码的开头处插入一个标号。
```

![image-20210622203514093](https://img-blog.csdnimg.cn/img_convert/69642febfa6d175ba26c85e64075b6fc.png)

![image-20210622203615011](https://img-blog.csdnimg.cn/img_convert/2c2b3802951389f2c8e32f8af4520488.png)

```
以上两个产生式，虽然不用产生新的代码，带需要将E1.code接管过来。因为在规约完成后，E1.code将被弹出。
```

![image-20210622203921427](https://img-blog.csdnimg.cn/img_convert/02fe87dc90f1acee6ea6123997751ff9.png)

### 8.8.3 根据属性文法翻译布尔表达式

![image-20210622204039556](https://img-blog.csdnimg.cn/img_convert/31b8d1d087a5ec4a4cbb2ad174264f74.png)

1.首先建立语法树。

2.按照自上而下的方法对E.true，E.false赋值。

![image-20210622204317542](https://img-blog.csdnimg.cn/img_convert/286a94847b4ed01ca51f4bcea95727d9.png)

3.再按照自下而上的方法进行逐步规约，（计算E.code）。

![image-20210622204354429](https://img-blog.csdnimg.cn/img_convert/376f585c025fcc15034b7c71fd8d655d.png)

```
以上分析方式经历了多次扫描：1.为给定的输入串构造一棵语法树2.自上而下分析，计算E.true,E.false等继承属性3.自下而上分析，计算E.code综合属性那么能否只以便扫描就可生成代码呢？
```

### 8.8.4 一遍扫描实现布尔表达式的翻译

#### 8.8.4.1 概述

![image-20210622205549615](https://img-blog.csdnimg.cn/img_convert/b415088803ac6253a6a9cf04df2b0eda.png)

![image-20210622205653575](https://img-blog.csdnimg.cn/img_convert/a1dc25e873257a62709aa3001d9249ca.png)

![image-20210622205744134](https://img-blog.csdnimg.cn/img_convert/8e4eed36313903463ba25d1b16421ca0.png)

```
采用自下而上一遍扫描的方法：当想要将a<b规约为E时，产生两条代码：if a<b goto _1goto _2_1，_2的位置本来应该填的是E.true和E.false。但由于我们采用的是自下而上一遍扫描的分析方法，所以此时我们并不知道E.true和E.false的值。因此只能将其空着，等到知道这些值的时候再回填。
```

#### 8.8.4.2 引入语义变量和过程

![image-20210622210200433](https://img-blog.csdnimg.cn/img_convert/b7af0c1a3f71323770282dd1dc5c300d.png)

![image-20210622210228829](https://img-blog.csdnimg.cn/img_convert/c6986719f1af42bc997987bce7661e79.png)

![image-20210622210314887](https://img-blog.csdnimg.cn/img_convert/0a24dcb99456bc5e08a98c545fc49164.png)

#### 8.8.4.3 布尔表达式的文法

![image-20210622210410115](https://img-blog.csdnimg.cn/img_convert/9c6132c22ed1e4ba4fef7f4e4bbb2420.png)

```
因此在E2的开头引入非终结符M。M用于规约一个空串，规约时的动作正是记录下E2开头的地址。
```

![image-20210622210544567](https://img-blog.csdnimg.cn/img_convert/5f4cd27400e98e9da3d1fd8830271001.png)

### 8.8.5 布尔表达式的翻译模式

```
以下翻译模式适合自下而上分析：只需要考虑E.truelist,E.falselist,M.quad,E.code
```

![image-20210622210713903](https://img-blog.csdnimg.cn/img_convert/9b5b5021405858f876cd652111c735b3.png)

![image-20210622210745377](https://img-blog.csdnimg.cn/img_convert/c25afb363a87497e8e47a2c219575014.png)

![image-20210622212323484](https://img-blog.csdnimg.cn/img_convert/419e747ed65b0ed5391b65b1b81de112.png)

```
对上述翻译模式的说明：1.E1.truelist为E1生成的代码中一些需要回填跳转地址的代码组成的链表。这些代码需要回填的地址为：当E1为真时，需要跳转到的代码的地址。2.在if （E1 or E2） then S1 else S2这个语境中。当E1为真时，可以直接跳转到S1代码的开头。当E1为假时，需要跳转到E2代码的开头。而在规约 E1 or E2 到E时，E2代码开头的地址已知，所以可以回填E1.falselist。而S1代码的开头地址，在分析E-> E1 or M E2时还不知道。需要分析到‘then’时才知道S1开头的地址。所以此时E1.truelist还不能回填，需要交给E.truelist接管。3.将E1.truelist交给E.truelist接管在理解上也是合理的。因为当E为真时，需要跳转到的地址也是S1产生的第一句代码。
```

![image-20210622212335991](https://img-blog.csdnimg.cn/img_convert/21e602aa20e80e7d49f1df4799a9e127.png)

![image-20210622212434172](https://img-blog.csdnimg.cn/img_convert/2eda07ff7d6fbed7dc7c9d8ed496ba15.png)

![image-20210622212506121](https://img-blog.csdnimg.cn/img_convert/54aa611383090574401fb64f4f480bce.png)

### 8.8.6 布尔表达式的翻译示例

![image-20210622212805585](https://img-blog.csdnimg.cn/img_convert/fa3657ebd65325f008ce49e748850f6f.png)

## 8.9 常用的控制语句

![image-20210623111629348](https://img-blog.csdnimg.cn/img_convert/00cfbfc65520a23f1a04c31eb079427f.png)

## 8.10 控制语句的属性文法

```
只需要考虑E.true,E.false,E.code,S.next,S.code属性
```

### 8.10.1 if语句的属性文法

![image-20210623111946097](https://img-blog.csdnimg.cn/img_convert/70c3cc250fbfb165ebeef7cf1b24696f.png)

![image-20210623112058443](https://img-blog.csdnimg.cn/img_convert/41f1fdd9b338c552e93ceac190bf040a.png)

```
S.next是一个继承属性，存放S语句后面需要执行的代码的首地址。因为是继承属性，S又在产生式右侧，所以S.next在规约时是已知的。
```

![image-20210623112314251](https://img-blog.csdnimg.cn/img_convert/864c20e4c2b9bdc87917db3a389646c1.png)

![image-20210623112423851](https://img-blog.csdnimg.cn/img_convert/9857ad6b4675bd2af441e2ff1d07ded2.png)

### 8.10.2 while语句的属性文法

![image-20210623112459613](https://img-blog.csdnimg.cn/img_convert/97954da086df3cc010c79d062f09a209.png)

![image-20210623112515671](https://img-blog.csdnimg.cn/img_convert/79b37eefe3c9501f4cf4f574d798c010.png)

```
其实可以不用添加S.begin属性，如下图所示：
```

![image-20210626174106278](https://img-blog.csdnimg.cn/img_convert/582bec7d7a6696516fe08fe75da8388b.png)

## 8.11 控制语句的属性计算

![image-20210623113118361](https://img-blog.csdnimg.cn/img_convert/06f9a1a03b79761d39664edc849b0ff4.png)

1.建立语法树

2.自上而下扫描，计算S.begin,S.next,E.true,E.false

3.自下而上规约,计算S.code,E.code

![image-20210623114956176](https://img-blog.csdnimg.cn/img_convert/3cc939032ddec12af9fedeec3d9c36d5.png)

![image-20210623114932709](https://img-blog.csdnimg.cn/img_convert/438e02d5ed3e478eaabf138dfad47c0b.png)

![image-20210623115009216](https://img-blog.csdnimg.cn/img_convert/5fbe3ffeddc7a6ff0e59832665c6c0f4.png)

![image-20210623115019650](https://img-blog.csdnimg.cn/img_convert/bb8a0e5d6132cb50ccd216d90a2e36bb.png)

![image-20210623115029531](https://img-blog.csdnimg.cn/img_convert/d12e6dbfcefdafcf6f036e2b8d066319.png)

![image-20210623115040926](https://img-blog.csdnimg.cn/img_convert/a695c440f453db99c79eb798e6d66bd4.png)

## 8.13 含有break语句的翻译模式

```
只需要考虑E.true,E.false,E.code,S.next,S.break,S.next
```

![image-20210626192647554](https://img-blog.csdnimg.cn/img_convert/541d877992980bf87ba1e3cf7902188f.png)

![image-20210626192657754](https://img-blog.csdnimg.cn/img_convert/d268e47e324815fdd376241fb491c06e.png)

## 8.14 一遍扫描翻译控制语句

![image-20210623115428900](https://img-blog.csdnimg.cn/img_convert/f3293f04a5499d433e977f4b0396b5b9.png)

### 8.12.1 if语句的一遍扫描翻译

```
需要回填的有：E.truelist,E.falselist，S.nextlist,N.nextlist也就是说，需要回填的其实都是E，和S的继承属性
```

![image-20210623115834740](https://img-blog.csdnimg.cn/img_convert/b52a11d3f00fb40cce548b261a4cfcab.png)

![image-20210623115847229](https://img-blog.csdnimg.cn/img_convert/d0706c6b69899c6ada31920e0d265305.png)

![image-20210623115902036](https://img-blog.csdnimg.cn/img_convert/fd88d5898eec8945cb014736fcb7374f.png)

![image-20210623120710198](https://img-blog.csdnimg.cn/img_convert/1930ae303adaf53fbfd0334340be995a.png)

### 8.12.2 while语句的一遍扫描翻译

![image-20210623121706296](https://img-blog.csdnimg.cn/img_convert/ec120b83e96a4afbabcf31f0fcd25e75.png)

![image-20210623121806415](https://img-blog.csdnimg.cn/img_convert/8398d3b82c93fb1e29aec1d5031e638c.png)

### 8.12.3 复合语句的一遍扫描翻译

![image-20210623121821882](https://img-blog.csdnimg.cn/img_convert/19806973110168c08cbcbc0fe11cdea1.png)

![image-20210623121900147](https://img-blog.csdnimg.cn/img_convert/e0c53abfd994f5a4f47305ce028a799c.png)

![image-20210623121952984](https://img-blog.csdnimg.cn/img_convert/5a0dd07fadb7319c3f56c764b7d8bd2e.png)

## 8.13 一遍扫描翻译控制语句示例

![image-20210623144431532](https://img-blog.csdnimg.cn/img_convert/5a2e797f64445951337f343467db55c1.png)

![image-20210623144440805](https://img-blog.csdnimg.cn/img_convert/857154f33a2bf850c51de9e94b60ef36.png)

# 第九章 运行时存储组织

## 9.1 参数传递

![image-20210623152056794](https://img-blog.csdnimg.cn/img_convert/64f7e88f5dc1ecef017378f0d0ca7bf7.png)

![image-20210623152112397](https://img-blog.csdnimg.cn/img_convert/d32fcfbdeaf0584d2c67dc35fcc78010.png)

### 9.1.1 传地址

![image-20210623152223897](https://img-blog.csdnimg.cn/img_convert/a0669323c02568704f916e4f87976e07.png)

![image-20210623152249807](https://img-blog.csdnimg.cn/img_convert/29b590775d2c5aa9c026f21fac4102f0.png)

![image-20210623152305519](https://img-blog.csdnimg.cn/img_convert/5fbfeb5c72af1f98299418cb53c00cdc.png)

![image-20210623152440946](https://img-blog.csdnimg.cn/img_convert/8a211fa5e8fb46c59833fe8fb34b3709.png)

### 9.1.2 得结果

![image-20210623152459451](https://img-blog.csdnimg.cn/img_convert/e63b7534985eacd8324bf630f0b061a8.png)

![image-20210623152528167](https://img-blog.csdnimg.cn/img_convert/05df1e34a30651aa12c66f3370c71107.png)

![image-20210623152537870](https://img-blog.csdnimg.cn/img_convert/031ab34febd4037318ac05172eaf42d0.png)

### 9.1.3 传值

![image-20210623152725695](https://img-blog.csdnimg.cn/img_convert/a721392676fac2c60261d3aa73e6c779.png)

![image-20210623152732750](https://img-blog.csdnimg.cn/img_convert/fafb4fef7d363e6e43c47dab983ffb1a.png)

![image-20210623152746022](https://img-blog.csdnimg.cn/img_convert/7e9134fb50499ec7700058bd4096cf78.png)

### 9.1.4 传名

![image-20210623152756331](https://img-blog.csdnimg.cn/img_convert/631d44cc99e2b72bf93a867abac6df29.png)

![image-20210623152930078](https://img-blog.csdnimg.cn/img_convert/4aaa72e975f1e51ae323d10d30147c14.png)

```
直接将函数体写到调用处，然后用实参替换掉形参。如果函数体内的局部变量有和实参冲突的，那么将这些局部变量换名。
```

![image-20210623153028134](https://img-blog.csdnimg.cn/img_convert/57cddf3b54838c2176c9741490f995b9.png)

![image-20210623153037347](https://img-blog.csdnimg.cn/img_convert/ac0cd5ad8f54ced33f8171b198abd392.png)

## 9.2 目标程序运行时的活动

### 9.2.1 过程的活动与生存期

![image-20210623153218126](https://img-blog.csdnimg.cn/img_convert/efbeb6a4fe42b8cde64889d0132c158c.png)

![image-20210623153243039](https://img-blog.csdnimg.cn/img_convert/8783dc86c39ea82ff57f8438e90bfb84.png)

### 9.2.2 运行时的存储组织

![image-20210623153316043](https://img-blog.csdnimg.cn/img_convert/483bbd71a355931bde0f39173427d656.png)

![image-20210623153343200](https://img-blog.csdnimg.cn/img_convert/01f53b5d83fea688e99c50d699109c21.png)

![image-20210623153400788](https://img-blog.csdnimg.cn/img_convert/b1e1440fc7d132143c372fa27e81720e.png)

## 9.3 静态存储管理

![image-20210623153423798](https://img-blog.csdnimg.cn/img_convert/f4f80d41bbc4995cbcbfd09783069187.png)

![image-20210623153525133](https://img-blog.csdnimg.cn/img_convert/fc3c275f08358cc0c09df550b994d870.png)

![image-20210623153547712](https://img-blog.csdnimg.cn/img_convert/73bac24d12806066d3c88c831c0fdd46.png)

![image-20210623153623176](https://img-blog.csdnimg.cn/img_convert/f2fa42bd263eeb969a327498d37ff8f5.png)

## 9.4 动态存储管理概述

### ![image-20210623160517402](https://img-blog.csdnimg.cn/img_convert/47791251eb604ae259b4fb5d3b8ad836.png)

![image-20210623160528965](https://img-blog.csdnimg.cn/img_convert/9c810298c790f92973c665340aabcca1.png)

![image-20210623160556182](https://img-blog.csdnimg.cn/img_convert/ceae65c9922022f2686e9432cc9521f6.png)

![image-20210623160606955](https://img-blog.csdnimg.cn/img_convert/4e2a9e14b33021a21e6b4a80c4bb26b6.png)

## 9.5 非嵌套过程语言的动态存储管理

### 9.5.1 非嵌套过程语言的特点

![image-20210623160652011](https://img-blog.csdnimg.cn/img_convert/7300b7e11c4f220fe974fdf7231948c1.png)

### 9.5.2 栈式管理与活动记录

![image-20210623160715058](https://img-blog.csdnimg.cn/img_convert/bc671e269ae99780bdc1cc34bd51a56b.png)

![image-20210623160756559](https://img-blog.csdnimg.cn/img_convert/bc3d7d68a284be6b510231b76c0cee20.png)

### 9.5.3 过程调用和过程返回

![image-20210623160816056](https://img-blog.csdnimg.cn/img_convert/829bbb7a0049b20c0e9d52a523bb9200.png)

![image-20210623161003985](https://img-blog.csdnimg.cn/img_convert/886c92d43d4ef531d476eccf64c773f5.png)

![image-20210623161013743](https://img-blog.csdnimg.cn/img_convert/dafdddef2f02526fbbdd26785b7f4af1.png)

![image-20210623161057770](https://img-blog.csdnimg.cn/img_convert/1881573b92a26ff049108df7171efef7.png)

## 9.6 嵌套过程语言的动态存储管理-静态链

### 9.6.1 嵌套过程语言的动态管理



![img](res/基础知识/image-20210623161302059.png)

![img](res/基础知识/image-20210623161323262.png)

### 9.6.2 静态链方法

![img](res/基础知识/image-20210623161530637.png)

![image-20210623161803222](https://img-blog.csdnimg.cn/img_convert/804eccd7cff3a61d04da173330383e89.png)

静态链相当于某个函数在源代码中的位置，相对于该源代码的结构而言，而不是调用时的结构

动态链是执行上一个基本块的位置

![image-20210623162155066](https://img-blog.csdnimg.cn/img_convert/e737e73df23cb4d535d6dc543b7ee509.png)

### 9.6.3 静态链方法示例

![image-20210623161848763](https://img-blog.csdnimg.cn/img_convert/21d5330233316a78bed442a8dbbe5ef2.png)

![img](res/基础知识/image-20210623162326233.png)

```
加入当前在过程R中，需要访问b(1,4)。R处于第2层，需要访问第1层的变量。这是就需要沿着静态链向上回溯一次，到达地址11，DX=11.然后再DX+4=15,即可找到变量b的地址。
```

![img](res/基础知识/image-20210623162411966.png)

![img](res/基础知识/image-20210623162423900.png)

## 9.8 嵌套过程语言的动态存储管理-Display表

```
静态链的一个缺点就是访问外层变量的效率较低。Display表方法可以解决这个缺点。
```

### 9.8.1 Display表方法

![image-20210623163253718](https://img-blog.csdnimg.cn/img_convert/78e5ad9102b52a83ede375a9cae4fab4.png)

### 9.8.2 Display表的维护

![image-20210623163305540](https://img-blog.csdnimg.cn/img_convert/48f128dfc3af65b5281c81d6243892ec.png)

![image-20210623163315792](https://img-blog.csdnimg.cn/img_convert/86337b5b780fbfed1a9c7d5d4f0c20bf.png)

![image-20210623163349786](https://img-blog.csdnimg.cn/img_convert/15a7ad0312531b9618b3cdea29d01c97.png)

![image-20210623163445478](https://img-blog.csdnimg.cn/img_convert/ab234e35d8393e3b7fc239f8085dc951.png)

![image-20210623163454408](https://img-blog.csdnimg.cn/img_convert/c18ef783862babdd51b92db8d5b575c6.png)

![image-20210623163600499](https://img-blog.csdnimg.cn/img_convert/805529e984ff13bcae7650cb18450697.png)

### 9.8.3 Display表方法示例

![image-20210623163831682](https://img-blog.csdnimg.cn/img_convert/74e36e60b94f9944ac6761e416935c21.png)

### 9.8.4 HUST的Display表方法

以上的方法是基于国防科技大学的慕课讲解，以下为华科方法：

#### 9.8.4.1 方案一：保存整个Display表

![image-20210625210209381](https://img-blog.csdnimg.cn/img_convert/ef34cea5755b895bb5596e8709bbf0d1.png)

```
说明：方案一其实和国防科大讲解的区别不大。都是每个栈帧都维护自己的一张display表。并且维护方法也相同：假设当前栈顶的程序为第i层（从0计数），那么就从下一层栈帧的display表中取出i项，然后再加上栈顶栈帧的表项即可。这里列出这个方法是为了熟悉华科的这种表示方法。
```

#### 9.8.4.2 方案二 只保存Display表的表项Display\[i\]

![image-20210625210651468](https://img-blog.csdnimg.cn/img_convert/ecbf6708c1b3043c42c044b38431ba84.png)

```
只有一个全局的Display表，每个栈帧中只保存一个表项。以下介绍这个Display表的维护方法：
```

![image-20210625212444000](https://img-blog.csdnimg.cn/img_convert/3af5c068a2ec331ad9f60bb00987d50b.png)

```
上图为main调用S后的运行栈和Display表的情况，下面函数S会调用函数P：
```

![image-20210625212504692](https://img-blog.csdnimg.cn/img_convert/7afe6adbb1490edd9d58846cced4c187.png)

```
调用函数P，运行栈的栈顶增加函数P的栈帧，P是第1层，栈帧P中存有D[1]的位置。按照正常维护Display表的方法，因为P处于第一层，需要从Display表中取出一项，然后再添加上P的地址。也就是说当前Display表中的D[1]需要被替换为FP2，为了方便当P的栈帧弹出时Display表还能退回正确的状态，所以需要将FP1保存到P栈帧的D[1]中。维护完成后的运行栈与Display表如下图：
```

![image-20210625212515273](https://img-blog.csdnimg.cn/img_convert/5611ce1c56c91dde51873b56127dd515.png)

```
下面函数P调用函数Q，Q处于第二层，需要从Display表中取出两项，然后再加上Q栈帧的地址。如下图所示。由于D[2]的加入并没有替换掉原来Display表中的任何表项，所以Q栈帧中的D[2]可以为空。
```

![image-20210625213102816](https://img-blog.csdnimg.cn/img_convert/6663c1d7c174db1079828e421eb541b5.png)

### 9.8.5 过程调用和返回

![image-20210623164014364](https://img-blog.csdnimg.cn/img_convert/7e153f8d22448b9a34bc5fafe898ceb8.png)

![image-20210623164021286](https://img-blog.csdnimg.cn/img_convert/ffe30869e970d913d026dca0296e04a3.png)

![image-20210623164027084](https://img-blog.csdnimg.cn/img_convert/aa05f0462da307e0135b50bd9377898a.png)

![image-20210623164038230](https://img-blog.csdnimg.cn/img_convert/84ae1e7ff98bc1abb9546813da0af99b.png)

![image-20210623164044524](https://img-blog.csdnimg.cn/img_convert/1f9fd273da1a82a702794011f30cb436.png)

# 第十章 优化与目标代码生成

## 10.1 优化概述

### 10.1.1 优化的基本概念

![image-20210624142402194](https://img-blog.csdnimg.cn/img_convert/5b1e86dacbca14db2c38a91aac3131bd.png)

![image-20210624142505503](https://img-blog.csdnimg.cn/img_convert/a35f643a53761cf2cef3418c326f21e8.png)

### 10.1.2 优化示例

#### 10.1.2.1 删除公共子表达式

![image-20210624164233432](https://img-blog.csdnimg.cn/img_convert/4654e92b22613a399ff1493fd3beeaff.png)

![image-20210624164241767](https://img-blog.csdnimg.cn/img_convert/b17d29ffaf1bbdba0a0f0a8c60ca6162.png)

![image-20210624164256205](https://img-blog.csdnimg.cn/img_convert/363662fa5d63e957ff909ec85ab29619.png)

![image-20210624164326741](https://img-blog.csdnimg.cn/img_convert/a7ef228d34936d66a9c486da923ad57e.png)

#### 10.1.2.2 复写传播

![image-20210624164350854](https://img-blog.csdnimg.cn/img_convert/e6aaa3db462333b5b42bac1eddf505ad.png)

![image-20210624164358432](https://img-blog.csdnimg.cn/img_convert/b4e19a167317ffb32ca2a0ce8b6c6430.png)

#### 10.1.2.3 删除无用赋值

![image-20210624164433475](https://img-blog.csdnimg.cn/img_convert/174113a8ece05e9b06d7a1ea7b447f8f.png)

![image-20210624164441775](https://img-blog.csdnimg.cn/img_convert/39cccdfb0a2ee0404afea275fdc68ac1.png)

#### 10.1.2.4 强度削弱

![image-20210624164512613](https://img-blog.csdnimg.cn/img_convert/363a4d7502f893848de5891f05d7c182.png)

![image-20210624164521465](https://img-blog.csdnimg.cn/img_convert/06379cddd209be005c8fb31403998ac9.png)

#### 10.1.2.5 删除归纳变量

![image-20210624164549553](https://img-blog.csdnimg.cn/img_convert/5f2f7fe9e2ecf53330cf62f881ce6be2.png)

![image-20210624164557616](https://img-blog.csdnimg.cn/img_convert/73b54a70b39927a80a513d46176243e1.png)

## 10.2 局部优化-基本块划分

### 10.2.1 基本块

**1.基本块的概念**

程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。

![image-20210624143008686](https://img-blog.csdnimg.cn/img_convert/17ce88abc282415066116d7fc96a6d1d.png)

**2.定值与引用**

对三地址语句为x:=y+z， 称**对x定值**并**引用y和z**

**3.活跃的**

基本块中的一个名字在程序中的某个给定点是活跃的，是指如果在程序中(包括在本基本块或在其它基本块中) 它的值在该点以后被引用。

即在这个点给这个名字的值将来会被引用到。

### 10.2.2 基本块划分算法

![image-20210624143049019](https://img-blog.csdnimg.cn/img_convert/d50d25bfd0ddbe70035061f4bb33e1d3.png)

![image-20210624143148603](https://img-blog.csdnimg.cn/img_convert/85f1a5d56bc75772cce34cd245e722ec.png)

![image-20210624143159320](https://img-blog.csdnimg.cn/img_convert/7d481e25f824f20f9575038ffc7ac05d.png)

```
实操方法：1.首先将程序的第一条语句标记上入口语句。2.寻找程序中所有的条件跳转语句以及无条件跳转语句。将它们跳转到的语句标记上入口语句。3.寻找所有的条件跳转语句，将条件跳转语句的下一条语句标记上入口语句。4.按照上述第二步寻找到对应的出口语句。
```

![image-20210624143611989](https://img-blog.csdnimg.cn/img_convert/8f77ddba298084e0ddcb1b7bfd661db5.png)

![image-20210624143625372](https://img-blog.csdnimg.cn/img_convert/f39a4a8a150950006eab8a8c838e644f.png)

在该流程中，由于当前操作所需数据在上次操作已存在寄存器中，因此不必进行多余的加载数据操作，直接使用即可

**无多余的语句，不用删除冗余语句。**

### 10.2.3 流图

![image-20210624143927001](https://img-blog.csdnimg.cn/img_convert/d673dc6cab47a0fc61ec34f1850402df.png)

## 10.3 局部优化-基本块优化

### 10.3.1 基本块的DAG表示

![image-20210624144012382](https://img-blog.csdnimg.cn/img_convert/c83ede7e9abdd64ef7fdc1fc35ca48b8.png)

![image-20210624144023623](https://img-blog.csdnimg.cn/img_convert/3095ce1aa353552b847243ba35aa04dd.png)

![image-20210624144211843](https://img-blog.csdnimg.cn/img_convert/c426a3c5cf021b605d78ce2610b49046.png)

![image-20210624144228143](https://img-blog.csdnimg.cn/img_convert/5175ce6c9fceb830f6f4527bfea00525.png)

![image-20210624144303855](https://img-blog.csdnimg.cn/img_convert/1501b15e214b16940c63c93a27c97736.png)

![image-20210624144332672](https://img-blog.csdnimg.cn/img_convert/9dd372346a40f39e1ce7c5da8e4b7636.png)

### 10.3.2 基本块的优化算法

![image-20210624144535073](https://img-blog.csdnimg.cn/img_convert/d7575dcf23f2b3fa598c96d389d21f31.png)

### 10.3.3 构造基本块DAG的示例

![image-20210624145500431](https://img-blog.csdnimg.cn/img_convert/b04ebc633133b67d56e851c8249b43a9.png)

![image-20210624145511268](https://img-blog.csdnimg.cn/img_convert/dd053e3e2ef8775a484c3e33169947e4.png)

![image-20210624145521555](https://img-blog.csdnimg.cn/img_convert/3f1ccad92a9f481cc0f85ab1fde81c42.png)

### 10.3.4 基本块的DAG构造算法

![image-20210624145619693](https://img-blog.csdnimg.cn/img_convert/f83a822bd8ff18f055d177f5108cebe4.png)

**1.0型四元式：A:=B**

```
1.准备操作数的结点如果NODE(B)无定义，则构造一标记为B的叶结点并定义NODE(B)为这个结点;2. 删除无用赋值如果NODE(A)无定义，则构造一标记为A的叶结点并定义NODE(A)为这个结点;否则，先把A从NODE(A)结点上的附加标识符集中删除(注意，如果NODE(A)是叶结点，则其A标记不删除)。把A附加到新结点n上并置NODE(A)=n。转处理下一四元式
```

**2\. 1型四元式： A:=OP B**

```
1.准备操作数的结点如果NODE(B)无定义，则构造一标记为B的叶结点并定义NODE(B)为这个结点;2.合并已知量(1) 如果NODE(B)是标记为常数的叶结点，则转2(2)；否则，转3(1)(2) 执行op B (即合并已知量)。令得到的新常数为P。如果NODE(B)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P作标记的叶结点n。置NODE(P)=n，转43. 删除公共子表达式检查DAG中是否已有一结点，其唯一后继为NODE(B)且标记为op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为n。转4。4. 删除无用赋值如果NODE(A)无定义，则构造一标记为A的叶结点并定义NODE(A)为这个结点;否则，先把A从NODE(A)结点上的附加标识符集中删除(注意，如果NODE(A)是叶结点，则其A标记不删除)。把A附加到新结点n上并置NODE(A)=n。转处理下一四元式
```

**3\. 2型四元式： A:= B OP C**

```
1.准备操作数的结点如果NODE(B)无定义，则构造一标记为B的叶结点并定义NODE(B)为这个结点;如果NODE(C)无定义，则构造一标记为C的叶结点并定义NODE(C)为这个结点；转2(1)。2.合并已知量(1) 如果NODE(B)和NODE(C)都是标记为常数的叶结点，则转2(2)；否则，转3(2)(2)执行B op C (即合并已知量)。令得到的新常数为P。如果NODE(B)或NODE(C)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P作标记的叶结点n。置NODE(P)=n，转43.删除公共子表达式检查DAG中是否已有一结点，其左后继为NODE(B)，右后继为NODE(C)，且标记为op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为n。转4。4. 删除无用赋值如果NODE(A)无定义，则构造一标记为A的叶结点并定义NODE(A)为这个结点;否则，先把A从NODE(A)结点上的附加标识符集中删除(注意，如果NODE(A)是叶结点，则其A标记不删除)。把A附加到新结点n上并置NODE(A)=n。转处理下一四元式
```

## 10.4 循环优化

### 10.4.1 循环知识

**1.入口节点**

```
在程序流图G中，对于任意一个结点序列α，如果1.在结点序列之外存在一个结点指向结点序列中的结点V,或者2.结点序列中的结点V是程序首结点，则称结点V 为结点序列α的入口结点。 
```

![image-20210626150728578](https://img-blog.csdnimg.cn/img_convert/27ca083fee1d75d59551547c6a02ab10.png)

```
在程序流图（上图）中，结点序列如下。（1）{2,4,5}入口结点是2,4（2）{4,5,7}入口结点是4,7（3）{1,2,3,5}入口结点是1,2,5
```

**2.循环的概念**

```
循环是在程序流图中，具有下列性质的结点序列：⑴它是强连通子图；(指图中任意两个节点之间都能找到一条通路)⑵它有且仅有一个的入口结点。
```

```
例  在程序流图（上）中，结点序列如下。  （Ⅰ）循环：    {6}    {4，5，6，7}    {2、3、4、5、6、7}  （Ⅱ）非循环：     {2，4}    （入口不唯一）    {2，3，4} （入口不唯一）    {4，6，7} （入口不唯一）    {2，4，5} （非强连通子图）
```

**3.查找流图中的循环**

查找循环方法是基于流图中**回边**的。回边是以**必经结点**为前置的概念。

下面引入**必经结点和必经结点集**概念以及必经结点集的计算方法。

**(1)必经节点**

```
在流图中，对任意两个结点m和n，如果从首结点出发到达结点n的任一通路，都要经过结点m，则称结点m是结点n的必经结点或支撑结点，记为m DOM n。流图中结点n的所有必经结点集合，称为结点n的必经结点集，记为D(n)。 
```

![image-20210626151216022](https://img-blog.csdnimg.cn/img_convert/24f5a6e8c22d5657f8fe079821935f7f.png)

**注意：m DOM n 念作：m是n的必经节点**

**（2）计算所有结点n的必经结点集D（n）的算法**

```
n0是程序的开始节点；N代表所有的节点集合
```

![image-20210626151453496](https://img-blog.csdnimg.cn/img_convert/c4e7c667b3537a696b5dc13f5a16aa64.png)

```
算法原因：在流图中，如果p1、p2、…、pk是结点n的所有前驱，且结点d≠n，则d DOM n的充分必要条件是对于任意pi（1≤i≤k）,有d DOM pi 。 
```

![image-20210626151550541](https://img-blog.csdnimg.cn/img_convert/da34693ac3af19d120b5cce0b7c9eaa7.png)

**(3)回边**

```
如果节点m是节点n的必经节点，那么从n到m的边就叫做“回边”
```

![image-20210626152111157](https://img-blog.csdnimg.cn/img_convert/800ede67e80083879e2b7d195341e7b2.png)

**(4)循环查找算法**

```
P(n)为结点n的所有前驱结点集令流图G的一条回边n→m(m是n的必经节点)，求m为入口和n为出口之循环loop。
```

![image-20210626152545875](https://img-blog.csdnimg.cn/img_convert/f48c84ec4b5f2a3d3008ca12110fcdf2.png)

![image-20210626152552043](https://img-blog.csdnimg.cn/img_convert/7b74c5fa86a77af8f744eaf4462779c5.png)

![image-20210626152606730](https://img-blog.csdnimg.cn/img_convert/a195d5d0e6bb88905f1fd233bc878b0e.png)

### 10.4.2 代码外提

**1.定值到达**

![image-20210626113941318](https://img-blog.csdnimg.cn/img_convert/7243aeef5390c52117b2caae40e3e3ce.png)

**2.循环不变运算**

![image-20210626114001564](https://img-blog.csdnimg.cn/img_convert/8ec6772175f833dcd1aa7bb55499a997.png)

**3.查找循环不变运算的算法**

![image-20210626114124840](https://img-blog.csdnimg.cn/img_convert/c44fa4e8977da334ddd577d75bc26f51.png)

**4.代码外提**

把循环不变运算提到循环体外

![image-20210626114301857](https://img-blog.csdnimg.cn/img_convert/2be10f5207db81796b2247ea0c5e8c3d.png)

![image-20210626114316811](https://img-blog.csdnimg.cn/img_convert/247ff7c6878339c43fa374e30614fc2a.png)

![image-20210626114327855](https://img-blog.csdnimg.cn/img_convert/0f865dde65a209a10e88cdeae9196cca.png)

**5.外提的条件**

![image-20210626114355030](https://img-blog.csdnimg.cn/img_convert/8db8c3625f506ddf1ef141133b73bd31.png)

![image-20210626114404772](https://img-blog.csdnimg.cn/img_convert/bc8d2d24e3f988a2f771809af2e5f85b.png)

### 10.4.3 强度削弱

把程序中执行时间较长的运算转换为执行时间较短的运算

![image-20210626114447047](https://img-blog.csdnimg.cn/img_convert/dc09e1f063c3f0cf9e7f7f4ff51b95f4.png)

![image-20210626114454446](https://img-blog.csdnimg.cn/img_convert/fad6bc705b4c393bee62e8b9b42844c3.png)

![image-20210626114508422](https://img-blog.csdnimg.cn/img_convert/5853a67479c7c6d8195f12ffd54777ed.png)

![image-20210626114521456](https://img-blog.csdnimg.cn/img_convert/0e9dad601187cff38762ed4e275a35eb.png)

![image-20210626114532567](https://img-blog.csdnimg.cn/img_convert/e94db4e6cd19bdf2007d861bb4c288ea.png)

### 10.4.4 归纳变量

![image-20210626114605294](https://img-blog.csdnimg.cn/img_convert/f5d7182c91d0f1436a8731df645a6017.png)

![image-20210626114626337](https://img-blog.csdnimg.cn/img_convert/183dc258ca1a70b086681eaab09f5d27.png)

![image-20210626114637172](https://img-blog.csdnimg.cn/img_convert/a290b3f28156b3833275627342e02288.png)

### 10.4.5 强度削弱和删除归纳变量的统一算法框架

![image-20210626114836106](https://img-blog.csdnimg.cn/img_convert/6f0951dd290685ead422523f557c6bf1.png)
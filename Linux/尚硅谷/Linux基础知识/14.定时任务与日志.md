一、服务的简介与分类
1 、服务的分类

 RPM包默认安装的服务
这些服务是通过RPM包安装的，可以被服务管理命令识别。又分为两种子分类：
 独立的服务：就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管
理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更快速。
Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。
 基于xinetd的服务：这种服务就不能独立启动了，而是要依靠管理服务来调用这种服
务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd
服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，
由xinetd服务去唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释
放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有
在需要时才启动，不会占用过的的服务器资源。但是这种服务由于在有客户端请求时才
会被唤醒，所以相应时间相对较慢。
 源码包安装的服务

2 、 查询已经安装的服务和区分服务
[root@localhost ~]# chkconfig --list [服务名]
选项：
--list：列出所有RPM默认安装服务的自启动状态

二、RPM包默认安装的服务管理
1 独立服务管理
1 ）、 独立服务的启动管理
 使用/etc/init.d/目录中的启动脚本启动服务

云计算Linux课程系列
—————————————————————————————
[root@localhost ~]# /etc/init.d/httpd start
 使用service命令来启动独立的服务
[root@localhost ~]# service 独立服务名 start|stop|restart|...

2 ）、 独立服务的自启动管理
 使用chkconfig服务自启动管理命令
[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]
\#选项：
--level： 设定在哪个运行级别中开机自启动（on），或是关闭自启动（off）
[root@localhost ~]# chkconfig --level 2345 httpd on

 修改/etc/rc.d/rc.local文件，设置服务自启动
[root@localhost ~]# vi /etc/rc.d/rc.local
\#!/bin/sh

# 

# This script will be executed *after* all the other init scripts.

# You can put your own initialization stuff in here if you don't

# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local
/etc/rc.d/init.d/httpd start

 使用ntsysv命令管理自启动
[root@localhost ~]# ntsysv [--level 运行级别]
选项：
--level 运行级别：可以指定设定自启动的运行级别
这个命令的操作是这样的：
 上下键：在不同服务之间移动
 空格键：选定或取消服务的自启动。就是在服务之前是否打入“*”
 tab键：在不同项目间切换
 F1键：显示服务的说明

2 基于xinetd服务的管理
1 ）、 基于xinetd服务的启动
我们使用telnet服务来举例，telnet服务是用来进程系统远程管理的，端口时 23 。不过需要注
意的是telnet的远程管理数据在网络当中是明文传输，非常不安全。所以我们在生产服务器上是不
建议启动telnet服务的，我们这里只是举例而已。在生成服务器上，远程管理使用的是ssh协议，
ssh是加密的更加安全。
[root@localhost ~]# vi /etc/xinetd.d/telnet

# default: on

# description: The telnet server serves telnet sessions; it uses \

# unencrypted username/password pairs for authentication.

service telnet 服务的名称为telnet

云计算Linux课程系列
—————————————————————————————
{
flags = REUSE 标志为REUSE，设定TCP/IP socket可重用
socket_type = stream 使用TCP协议数据包
wait = no 允许多个连接同时连接
user = root 启动服务的用户为root
server = /usr/sbin/in.telnetd 服务的启动程序
log_on_failure += USERID 登陆失败后，记录用户的ID
disable = yes 服务不启动
}

[root@localhost ~]# vi /etc/xinetd.d/telnet
\#修改配置文件
service telnet
{
...省略部分输出...
disable = no 把yes改为no
}

[root@localhost ~]# service xinetd restart

2 ）、 基于xientd服务的自启动
 使用chkconfig命令管理自启动
 使用ntsysv命令管理自启动
[root@localhost ~]# chkconfig 服务名 on|off
\#基于xinetd的服务，没有自己的运行级别，是依靠xinetd服务的运行级别。所以不用指
\#定-- level选项

3 、 独立服务的启动脚本分析
既然独立的服务启动是依靠/etc/init.d/httpd这个脚本来进行启动管理的，那么这个脚本中到
底是什么样子的？既然我们已经学习了shell脚本，那么我们就来学习一下这个脚本到底是怎么实现
apache服务的管理的。
\#!/bin/bash

# 

# httpd Startup script for the Apache HTTP Server

# 

# chkconfig: - 85 15

\#自启动设定 - 代表自启动级别， 85 （S85）代表启动序号， 15 （K15）代表关闭序号。

# description: The Apache HTTP Server is an efficient and extensible \

# server implementing the current HTTP standards.

\#服务描述。以上两行用于apache自启动。

# processname: httpd

# config: /etc/httpd/conf/httpd.conf

# config: /etc/sysconfig/httpd

云计算Linux课程系列
—————————————————————————————

# pidfile: /var/run/httpd/httpd.pid

# 

### BEGIN INIT INFO

# Provides: httpd

# Required-Start: $local_fs $remote_fs $network $named

# Required-Stop: $local_fs $remote_fs $network

# Should-Start: distcache

# Short-Description: start and stop Apache HTTP Server

# Description: The Apache HTTP Server is an extensible server

# implementing the current HTTP standards.

### END INIT INFO

\#以上都是注释。

# Source function library.

. /etc/rc.d/init.d/functions
\#"."其实就是source，就是调用functions文件。

if [ -f /etc/sysconfig/httpd ]; then

. /etc/sysconfig/httpd
fi
\#判断httpd如果是文件，则调用httpd文件。

# Start httpd in the C locale by default.

HTTPD_LANG=${HTTPD_LANG-"C"}
\#定义变量HTTPD_LANG的值。并追加变量的值为C，即英文。

# This will prevent initlog from swallowing up a pass-phrase prompt if

# mod_ssl needs a pass-phrase from the user.

INITLOG_ARGS=""

# Set HTTPD=/usr/sbin/httpd.worker in /etc/sysconfig/httpd to use a server

# with the thread-based "worker" MPM; BE WARNED that some modules may not

# work correctly with a thread-based MPM; notably PHP will refuse to start.

# Path to the apachectl script, server binary, and short-form for messages.

apachectl=/usr/sbin/apachectl
httpd=${HTTPD-/usr/sbin/httpd}
prog=httpd
pidfile=${PIDFILE-/var/run/httpd/httpd.pid}
lockfile=${LOCKFILE-/var/lock/subsys/httpd}
\#定义一系列变量，用于后面的执行。
RETVAL=0
\#定义全局命令返回变量。

云计算Linux课程系列
—————————————————————————————
STOP_TIMEOUT=${STOP_TIMEOUT-10}

# The semantics of these two functions differ from the way apachectl does

# things -- attempting to start while running is a failure, and shutdown

# when not running is also a failure. So we just do it the way init scripts

# are expected to behave here.

start() {
echo -n $"Starting $prog: "
LANG=$HTTPD_LANG daemon --pidfile=${pidfile} $httpd $OPTIONS
RETVAL=$?
echo
[ $RETVAL = 0 ] && touch ${lockfile}
return $RETVAL
}
\#定义start函数，用于apache的启动。
\#如果守护进程/usr/sbin/httpd 启动成功（$RETVAL = 0），就建立/var/lock/subsys/httpd 文件（touch
\#${lockfile}）。通过$httpd变量执行/usr/sbin/httpd命令启动apache。通过$pidfile变量调用apache
\#的PID。通过变量$OPTIONS定义命令执行时的初始化环境配置，依赖/etc/sysconfig/httpd文件。

# When stopping httpd, a delay (of default 10 second) is required

# before SIGKILLing the httpd parent; this gives enough time for the

# httpd parent to SIGKILL any errant children.

stop() {
echo -n $"Stopping $prog: "
killproc -p ${pidfile} -d ${STOP_TIMEOUT} $httpd
RETVAL=$?
echo
[ $RETVAL = 0 ] && rm -f ${lockfile} ${pidfile}
}
\#定义stop函数，用来关闭apache服务，关闭服务之后会删除pid文件。
reload() {
echo -n $"Reloading $prog: "
if! LANG=$HTTPD_LANG $httpd $OPTIONS -t >&/dev/null; then
RETVAL=6
echo $"not reloading due to configuration syntax error"
failure $"not reloading $httpd due to configuration syntax error"
else

# Force LSB behaviour from killproc

LSB=1 killproc -p ${pidfile} $httpd -HUP
RETVAL=$?
if [ $RETVAL -eq 7 ]; then
failure $"httpd shutdown"
fi

云计算Linux课程系列
—————————————————————————————
fi
echo
}
\#定义reload函数，用于apache的重新加载。
\#通过/usr/sbin/httpd –t命令判断apache的配置文件。如果配置文件报错，则输出错误提示。如果配
\#置文件正确，则重新加载apache。

# See how we were called.

case "$1" in
\#判断执行脚本后的第一个参数的值，$1表示执行脚本时的第一个参数。
start)
start
;;
;;
\#如果参数值为start，则调用start函数。
stop)
stop
;;
\#如果参数值为stop，则调用stop函数。
status)
status -p ${pidfile} $httpd
RETVAL=$?
;;
\#如果参数值为status，则执行status –p $httpd命令测试apache状态。
restart)
stop
start
;;
\#如果参数值为restart，则先调用stop函数，再调用start函数
condrestart|try-restart)
if status -p ${pidfile} $httpd >&/dev/null; then
stop
start
fi
;;
\#如果参数值为condrestart或try -restart，则只有apache服务是已经运行时才先调用stop函数，再调
\#用start函数，重启apache。如果apache服务没有运行，则不重启apache。
force-reload|reload)
reload
;;
\#如果参数值为force-reload或reload，则调用reload函数。
graceful|help|configtest|fullstatus)
$apachectl $@

云计算Linux课程系列
—————————————————————————————
RETVAL=$?
;;
\#如果参数是graceful或help或configtest或fullstatus，则执行/usr/sbin/apachectl命令，并把参
\#数作为命令的参数传入apachectl命令。
*)
echo $"Usage: $prog
{start|stop|restart|condrestart|try-restart|force-reload|reload|status|fullstatus|graceful|help|config
test}"
RETVAL=2
\#如果输出的参数不是以上任何参数，则输出错误信息
esac

exit $RETVAL
通过这个脚本，我们可以对apache服务的启动有更深的了解了。

三、源码包安装的服务管理
.1 源码包服务的启动管理
[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...
\#源码包服务启动管理

2 源码包服务的自启动管理
root@localhost ~]# vi /etc/rc.d/rc.local
\#修改自启动文件
\#!/bin/sh

# 

# This script will be executed *after* all the other init scripts.

# You can put your own initialization stuff in here if you don't

# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local
/usr/local/apache2/bin/apachectl start

3 让源码包服务被服务管理命令识别
那么我们就做个试验，看看如何把源码包安装的apche变为和RPM包安装的apache一样，可以
被service、chkconfig、ntsysv命令识别吧。试验如下：
1 ）、卸载RPM包的apache服务
[root@localhost ~]# yum -y remove httpd
\#卸载RPM包的apache，避免对试验产生影响（生产服务器上慎用yum卸载，有可能造成服务器崩溃）。
[root@localhost ~]# service httpd start
httpd: 未被识别的服务
\#因为服务被卸载，所以service命令不能识别httpd命令

2 ）、安装源码包的apache服务，并启动

云计算Linux课程系列
—————————————————————————————
\#安装源码包的apache服务，具体安装方法参考软件安装章节。
[root@localhost ~]# /usr/local/apache2/bin/apachectl start
[root@localhost ~]# netstat -tlun | grep 80
tcp 0 0 :::80 :::* LISTEN
\#启动源码包的apache，查看端口确定已经启动

3 ）、让源码包的apache服务能被service命令管理启动
[root@localhost ~]# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache
\#service命令其实只是在/etc /init.d/目录中查找是否有服务的启动脚本，所以我们
\#只需要做个软链接把源码包的启动脚本链接到/etc/init.d/目录中，就能被service
\#命令管理了。为了大家的习惯，我把软链接文件起名为apache，不过注意这不是RPM包的apache哦！
[root@localhost ~]# service apache restart
\#虽然RPM包的apache被卸载，但是service命令也能够生效。

4 ）、让源码包的apache服务能被chkconfig命令管理自启动
[root@localhost ~]# vi /etc/init.d/apache
\#修改源码包apache的启动脚本（注意此文件是软链接，所以修改的还是源码包启动脚本）
\#!/bin/sh

# 

# chkconfig: 35 86 76

\#指定httpd脚本可以被chkconfig命令管理
\#格式是： chkconfig： 运行级别 启动顺序 关闭顺序
\#这里我们让apache在 3 和 5 级别能被chkconfig命令管理，启动顺序是S86，关闭顺序是K76
\#（自定顺序，不要和系统中已有的启动程序顺序冲突）

# description: source package apache

\#说明，内容随意
\#以上两句话必须加入，才能被chkconfig命令识别
...省略部分输出...

[root@localhost ~]# chkconfig --add apache
\#让chkconfig命令能够管理源码包安装的apache。
[root@localhost ~]# chkconfig --list | grep apache
apache 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭
\#很神奇吧，虽然RPM包的apche被删除了，但是chkconfig命令可以管理源码包apache
\#了

5 ）、让ntsysv命令可以管理源码包apache
\#ntsysv命令其实是和chkconfig命令使用同样的管理机制，也就是说ntsysv已经可以
\#进行源码包apache的自启动管理了。如图14-3所示：

云计算Linux课程系列
—————————————————————————————

图14- 3 ntsysv识别apache
总结下，如果想让源码包服务被 service命令识别并管理，只要做个软链接把启动脚本链接到
/etc/init.d/目录中即可。要想让源码包服务被chkconfig命令识别，除了需要把服务的启动脚本链
接到/etc/init.d/目录中，还要修改这个启动脚本，在启动脚本的开头加入：

# chkconfig: 运行级别 启动顺序 关闭

# description: 说明

然后需要使用“chkconfig --add 服务名”的方式把服务加入chkconfig命令管理中。命令格式
如下：
[root@localhost ~]# chkconfig [选项] [服务名]
选项：
--add： 把服务加入chkconfig命令的管理
--del： 把服务从chkconfig命令的管理中删除

例：
[root@localhost ~]# chkconfig –del httpd
\#把apache服务从chkconfig命令的管理中删除

四、总结服务管理

云计算Linux课程系列
—————————————————————————————

五、Linux中常见服务的作用
服务名称 功 能 简 介 建议
acpid 电源管理接口。如果是笔记本用户建议开启，可以监听内核层
的相关电源事件。

```
开启
```

anacron 系统的定时任务程序。cron的一个子系统，如果定时任务错过
了执行时间，可以通过anacron继续唤醒执行。

```
关闭
```

alsasound Alsa声卡驱动。如果使用alsa声卡，开启 关闭
apmd 电源管理模块。如果支持acpid，就不需要apmd，可以关闭 关闭
atd 指定系统在特定时间执行某个任务，只能执行一次。如果需要
则开启，但我们一般使用crond来进行循环定时任务。

```
关闭
```

auditd 审核子系统。如果开启了此服务，SELinux的审核信息会写入
/var/log/audit/audit.log文件，如果不开启，审核信息会记
录在syslog中

```
开启
```

autofs 让服务器可以自动挂载网络中的其他服务器的共享数据，一般
用来自动挂载NFS服务。如果没有NFS服务建议关闭

```
关闭
```

avahi-daemon Avahi 是 zeroconf 协议的实现。它可以在没有 DNS 服
务的局域网里发现基于 zeroconf 协议的设备和服务。除非
有兼容设备或使用zeroconf协议，否则关闭。

```
关闭
```

云计算Linux课程系列
—————————————————————————————
bluetooth 蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它 关闭
capi 仅对使用ISND设备的用户有用。 关闭
chargen-dgram 使用UDP协议的chargen server。 主要功能是提供类似远程
打字的功能。

```
关闭
```

chargen-stream 同上。 关闭
cpuspeed 可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来
节省电量。

```
开启
```

crond 系统的定时任务，一般的Linux服务器都需要定时任务帮助系
统维护。建议开启

```
开启
```

cvs 一个版本控制系统 关闭
daytime-dgram daytime使用TCP 协议的Daytime守护进程，该协议为客户机
实现从远程服务器获取日期 和时间的功能。

```
关闭
```

daytime-stream 同上。 关闭
dovecot 邮件服务中POP3/IMAP服务的守护进程。主要用来接收信件，
如果启动了邮件服务则开启，否则关闭

```
关闭
```

echo-dgram 服务器回显客户服务的进程。 关闭
echo-stream 同上。 关闭
firstboot 系统安装完成之后，有个欢迎界面，需要对系统进程初始设定。
就是这个进程的作用。既然不是第一次启动了，关闭吧

```
关闭
```

gpm 在字符终端（tty1-tty6）中可以使用鼠标复制和粘贴。就是
这个服务的功能。

```
开启
```

haldaemon 检测盒支持USB设备。如果是服务器可以关闭，个人机建议开
启。

```
关闭
```

hidd 蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。 关闭
hplip HP打印机支持，如果没有HP打印机关闭吧 关闭
httpd apache服务的守护进程。如果需要启动apache，就开启。 开启
ip6tables IPv6的防火墙，目前IPv6协议并没有使用，可以关闭 关闭
iptables 防火墙功能，Linux中防火墙是内核支持功能。这是服务器的
主要防护手段，必须开启。

```
开启
```

irda IrDA 提供红外线设备（笔记本，PDA ’s，手机，计算器等等）
间的通讯支持。关闭吧

```
关闭
```

irqbalance 支持多核处理器，让 CPU可以自动分配系统中断（IRQ），提
高系统性能。目前服务器多是多核CPU，请开启。

```
开启
```

isdn 使用ISDN设备连接网络。目前主流的联网方式是光纤接入和
ADSL，ISDN已经非常少见，请关闭

```
关闭
```

kudzu 该服务可以在开机时进行硬件检测，并会调用相关的设置软
件。建议关闭，仅在需要时开启

```
关闭
```

lvm2-monitor 该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM
方式，那么应该开启。建议开启

```
开启
```

mcstrans SELinux的支持服务。建议启动 开启
mdmonitor 该服务用来监测 Software RAID 或 LVM 的信息。不是必须服
务，建议关闭

```
关闭
```

云计算Linux课程系列
—————————————————————————————
mdmpd 该服务用来监测 Multi-Path 设备。不是必须服务 关闭
messagebus 这是 Linux 的 IPC（Interprocess Communication，进程间
通讯）服务，用来在各个软件中交换信息。个人建议关闭

```
关闭
```

microcode_ctl Intel系列的CPU可以通过这个服务支持额外的微指令集。 关闭
mysqld mysql数据库服务器。如果需要就开启，否则关闭 开启
named DNS服务的守护进程，用来进行域名解析。如果是DNS服务器
则开启，否则关闭

```
关闭
```

netfs 该服务用于在系统启动时自动挂载网络中的共享文件空间，比
如：NFS，Samba 等等。需要就开启，否则关闭

```
关闭
```

network 提供网络设置功能。通过这个服务来管理网络，所以开启 开启
nfs NFS（Network File System）服务，Linux与Linux之间的文
件共享服务。需要就开启，否则关闭

```
关闭
```

nfslock 在Linux中如果使用了NFS服务，为了避免同一个文件被不同
的用户同时编辑，所有有这个锁服务。有NFS是开启，否则关
闭

```
关闭
```

ntpd 该服务可以通过互联网自动更新系统时间，使系统时间永远都
准确。需要则开启，但不是必须服务

```
关闭
```

pcscd 智能卡检测服务，可以关闭 关闭
portmap 用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，
可以关闭。主要是NFS和NIS服务需要。

```
关闭
```

psacct 该守护进程支持几个监控进程活动的工具。 关闭
rdisc 客户端ICMP路由协议 关闭
readahead_early 在系统开机的时候，先将某些进程加载如内存整理，可以加快
一点启动速度。

```
关闭
```

readahead_later 同上 关闭
restorecond 用于给 SELinux 监测和重新加载正确的文件上下文。如果开
启SELinux则需要开启。

```
关闭
```

rpcgssd 与NFS有关的客户端功能。如果没有NFS就关闭吧。 关闭
rpcidmapd 同上 关闭
rsync 远程数据备份守护进程。 关闭
sendmail sendmail邮件服务的守护进程。如果有邮件服务就开启，否则
关闭

```
关闭
```

setroubleshoot 该服务用于将 SELinux 相关信息记录在日志
/var/log/messages中。建议开启

```
开启
```

smartd 该服务用于自动检测硬盘状态。建议开启 开启
smb 网络服务samba的守护进程。可以让Linux和Windows之间共
享数据。如果需要则开启

```
关闭
```

squid 代理服务的守护进程。如果需要则开启，否则关闭 关闭
sshd ssh加密远程登陆管理的服务。服务器的远程管理必须使用此
服务，不要关闭

```
开启
```

syslog 日志的守护进程。 开启
vsftpd vsftp服务的守护进程。如果需要FTP服务则开启，否则关闭 关闭

云计算Linux课程系列
—————————————————————————————
xfs 这个是X Window的字体守护进程。为图形界面提供字体服务，
如果不启动图形界面，就不用开启。

```
关闭
```

xinetd 超级守护进程。如果有依赖xinetd的服务就必须开启。 开启
ypbind 为NIS（网络信息系统）客户机激活ypbind服务进程。 关闭
yum-updatesd yum的在线升级服务。 关闭

云计算Linux课程系列
—————————————————————————————

第十五章：系统管理

```
尚硅谷云计算Linux课程
```

版本：V1. 0
讲师：沈超

一、进程管理
1 进程简介
1 ）、什么是进程管理？
那么到底什么是进程呢？进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，
都有自己的地址空间，并占用一定的系统资源。那么什么是程序呢？程序是人使用计算机语言编写的
可以实现特定目标或解决特定问题的代码集合。这么讲很难理解，那我们换一种说法：
 程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。
 进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被
加载如内存，操作系统给这个进程分配一个ID号，我们成为PID（进程ID）。

2 ）、进程管理的作用
 判断服务器健康状态：运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状
态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问
题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服
务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。
 查看系统中所有的进程：我们需要查看系统中所有正在运行的进程，通过这些进程可以判断
系统中运行了哪些服务，是否有非法服务运行。
 杀死进程：这是进程管理中最不常用的手段，当我需要停止服务时，会通过正确关闭命令来
停止服务（如apache服务可以通过service httpd stop来关闭）。只有当正确终止进程的
手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill
来终止，否则非常容易导致服务器崩溃）。

2 进程的查看
1 ）、 ps命令
ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加
入“-”，比如命令“ps aux”，其中“aux”是选项，但是这个选项不能加入“-”。这是因为ps
命令的部分选项需要遵守BSD操作系统的格式。所以ps命令的常用选项的组合是固定的。命令如下：
[root@localhost ~]# ps aux
\#查看系统中所有进程，使用BSD操作系统格式
[root@localhost ~]# ps -le
\#查看系统中所有进程，使用Linux标准命令格式。
选项：
a： 显示一个终端的所有进程，除了会话引线
u： 显示进程的归属用户及内存的使用情况
x： 显示没有控制终端的进程

云计算Linux课程系列
—————————————————————————————
-l： 长格式显示。显示更加详细的信息
-e： 显示所有进程，和-A作用一致

[root@localhost ~]# ps aux
\#查看系统中所有的进程
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.2 2872 1416? Ss Jun04 0:02 /sbin/init
root 2 0.0 0.0 0 0? S Jun04 0:00 [kthreadd]
解释下这个命令的输出：
 USER：该进程是由哪个用户产生的；
 PID：进程的ID号；
 %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；
 %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；
 VSZ：该进程占用虚拟内存的大小，单位KB；
 RSS：该进程占用实际物理内存的大小，单位KB；
 TTY：该进程是在哪个终端中运行的。其中 tty1-tty7 代表本地控制台终端（可以通过
alt+F1-F7 键切换不同的终端），tty1-tty6 是本地的字符界面终端，tty7 是图形终端。
pts/0- 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用的是pts/0终端，
第二个远程连接占用pts/1，依次增长。
 STAT：进程状态。常见的状态有：
 D：不可被唤醒的睡眠状态，通常用于I/O情况
 R：该进程正在运行
 S：该进程在睡眠状态，可被唤醒
 T：停止状态，可能是在后台暂停或进程在除错状态
 W：内存交互状态（从2.6内核开始无效）
 X：死掉的进程（应该不会出现）
 Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。
 <：高优先级（以下状态在BSD格式当中出现）
 N：低优先级
 L：被锁入内存
 s：包含子进程
 l：多线程（小写L）
 +：位于后台
 START：该进程的启动时间
 TIME：该进程占用CPU的运算时间，注意不是系统时间
 COMMAND：产生此进程的命令名

[root@localhost ~]# ps -le
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD
4 S 0 1 0 0 80 0 - 718 -? 00:00:02 init
1 S 0 2 0 0 80 0 - 0 -? 00:00:00 kthreadd
也来解释下这个命令的输出：
 F：进程标志，说明进程的权限，常见的标志有：

云计算Linux课程系列
—————————————————————————————
 1 ：进程可以复制，但是不能执行
 4 ：进程使用超级用户权限
 S：进程状态。具体的状态和“ps aux”命令中STAT状态一致
 UID：进程是哪个UID用户调用运行的
 PID：进程的ID号
 PPID：父进程的ID号
 C：该进程的CPU使用率，单位是百分比
 PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行
 NI：进程的优先级，也是数值越小越早被执行
 ADDR：该进程在内存的哪个位置
 SZ：该进程占用多大内存
 WCHAN：该进程是否运行。“-”代表正在运行
 TTY：该进程由哪个终端产生
 TIME：该进程占用CPU的运算时间，注意不是系统时间
 CMD：产生此进程的命令名

2)、 top命令
[root@localhost ~]# top [选项]
选项：
-d 秒数： 指定top命令每隔几秒更新。默认是 3 秒
-b： 使用批处理模式输出。一般和“-n”选项合用，用于把top命令重定向到
文件中
-n 次数： 指定top命令执行的次数。一般和“-b”选项合用
-p： 指定PID。只查看某个PID的进程
-s： 使top在安全模式运行，避免在交互模式中出现错误
-u 用户名： 只监听某个用户的进程
在top命令的交互模式当中可以执行的命令：
？或h： 显示交互模式的帮助
P： 以CPU使用率排序，默认就是此项
M： 以内存的使用率排序
N： 以PID排序
T： 按照CPU的累积运算时间排序，也就是用TIME+项排序
k： 按照PID号，给予某个进程一个信号。一般用于终止某个进程，信号 9
是强制终止的信号
r： 按照PID号，给某个进程重设优先级（Nice）值
q： 退出top
我们看看top命令的执行结果：
[root@localhost ~]# top
top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00
Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie
Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st
Mem: 625344k total, 571504k used, 53840k free, 65800k buffers
Swap: 524280k total, 0k used, 524280k free, 409280k cached

云计算Linux课程系列
—————————————————————————————

PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
19002 root 20 0 2656 1068 856 R 0.3 0.2 0:01.87 top
1 root 20 0 2872 1416 1200 S 0.0 0.2 0:02.55 init
2 root 20 0 0 0 0 S 0.0 0.0 0:00.03 kthreadd
我们解释下命令的输出，top命令的输出内容是动态的，默认每 3 秒刷新一次。命令的输出主要
分为两大部分：第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断
服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。

```
 我们先来说明第一部分的作用：
 第一行信息为任务队列信息，具体内容如表15-1所示：
内容 说明
12:26:46 系统当前时间
up 1 day, 13:32 系统的运行时间，本机已经运行 1 天 13 小时 32
分钟
2 users 当前登录了两个用户
load average: 0.00, 0.00, 0.00
系统在之前 1 分钟， 5 分钟， 15 分钟的平均负载。
如果CPU是单核，则这个数超过 1 ，就是高负载。
如果CPU是四核，则这个数超过 4 ，就是高负载。
（这个平均负载完全是个人经验来进行判断的，
一般认为不应该超过服务器CPU的核数。）
表15- 1 任务队列信息
 第二行为进程信息，具体内容如表15-2所示：
内容 说明
Tasks: 95 total 系统中的进程总数
1 running 正在运行的进程数
94 sleeping 睡眠的进程
0 stopped 正在停止的进程
0 zombie
僵尸进程。如果不是 0 ，需要手工检查僵尸进
程
表15- 2 进程信息
 第三行为CPU信息，具体内容如表15-3所示：
内容 说明
Cpu(s): 0.1%us 用户模式占用的CPU百分比
0.1%sy 系统模式占用的CPU百分比
0.0%ni 改变过优先级的用户进程占用的CPU百分比
99.7%id 空闲CPU的CPU百分比
0.1%wa 等待输入/输出的进程的占用CPU百分比
0.0%hi 硬中断请求服务占用的CPU百分比
0.1%si 软中断请求服务占用的CPU百分比
0.0%st
st（Steal time）虚拟时间百分比。就是当有
虚拟机时，虚拟CPU等待实际CPU的时间百分
```

云计算Linux课程系列
—————————————————————————————
比。
表15- 3 CPU信息
 第四行为物理内存信息，具体内容如表15-4所示：
内容 说明
Mem: 625344k total 物理内存的总量，单位KB
571504k used 已经使用的物理内存数量
53840k free 空闲的物理内存数量，我们使用的是虚拟机，
总共只分配了628MB内存，所以只有53MB的
空闲内存了
65800k buffers 作为缓冲的内存数量
表15- 4 物理内存信息
 第五行为交换分区（swap）信息
内容 说明
Swap: 524280k total 交换分区（虚拟内存）的总大小
0k used 已经使用的交互分区的大小
524280k free 空闲交换分区的大小
409280k cached 作为缓存的交互分区的大小
表15- 5 交互分区信息
 再来看top命令的第二部分输出，主要是系统进程信息。这部分和ps命令的输出比较类似，
只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。
 PID：进 程ID
 USER：该进程所属的用户
 PR：优先级，数值越小优先级越高
 NI：优先级，数值越小优先级越高
 VIRT：该进程使用的虚拟内存的大小，单位KB
 RES：该进程使用的物理内存的大小，单位KB
 SHR：共享内存大小，单位KB
 S：进程状态
 %CPU：该进程占用CPU的百分比
 %MEM：该进程占用内存的百分比
 TIME+：该进程总共占用的CPU时间
 COMMAND：进程的命令名

接下来我们举几个top命令常用的实例，来继续说明下top命令。比如我如果只想让top命令查
看某一个进程，这时就可以使用“-p选项”：
[root@localhost ~]# top -p 15273
\#只查看PID为 15273 的apache进程
在top命令的交互界面中按“q”键会退出top命令。也可以按“？”或“h”得到top命令交互
界面的帮助信息。也可以按“k”键终止某个进程，命令如下：
[root@localhost ~]# top
top - 14:10:15 up 1 day, 15:15, 3 users, load average: 0.00, 0.00, 0.00
Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie

云计算Linux课程系列
—————————————————————————————
Cpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st
Mem: 625344k total, 574248k used, 51096k free, 66840k buffers
Swap: 524280k total, 0k used, 524280k free, 409324k cached
PID to kill:15273  按“k”键，会提示输入要杀死进程的PID

如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的
进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可。不过top命令是
持续运行的，这时就需要“-b”和“-n”选项了，具体命令如下：
[root@localhost ~]# top -b -n 1 > /root/top.log
\#让top命令只执行一次，让后把结果保存到top.log文件中。这样就能看到所有的进程了

3 ）、 pstree命令
[root@localhost ~]# pstree [选项]
选项：
-p： 显示进程的PID
-u： 显示进程的所属用户

3 进程的管理
系统中可以识别的信号较多，我们可以使用命令“kill -l”或“man 7 signal”来查询，命令
如下：
[root@localhost ~]# kill -l

1. SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
2. SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
3. SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
4. SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
5. SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
6. SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
7. SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3
8. SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8
9. SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
10. SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
11. SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7
12. SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2
13. SIGRTMAX-1 64) SIGRTMAX
    这里我们介绍一下主要的信号，如表15- 6所示：
    信号代号 信号名称 说明
    1 SIGHUP 该信号让进程立即关闭，然后重新读取配置文件之后重启。
    2 SIGINT 程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。
    8 SIGFPE 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误,
    还包括溢出及除数为 0 等其它所有的算术的错误。
    9 SIGKILL 用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。一
    般用于强制终止进程。
    14 SIGALRM 时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使

云计算Linux课程系列
—————————————————————————————
用该信号。
15 SIGTERM 正常结束进程的信号，kill命令的默认信号。有时如果进程已
经发生问题，这个信号是无法正常终止进程的，我们才会尝试
SIGKILL信号，也就是信号 9 。
18 SIGCONT 该信号可以让暂停的进程恢复执行，本信号不能被阻断。
19 SIGSTOP 该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号
不能被阻断。

1 ）、 kill命令
[root@localhost ~]# kill [信号] PID

例 2 ：使用“-1”信号，让进程重启
[root@localhost ~]# kill -1 2246
\#使用“- 1 （数字一）”信号，让httpd的主进程重启动。

例 3 ：使用“-19”信号，让进程暂停。
[root@localhost ~]# vi test.sh
\#使用vi命令编辑一个文件，不要退出

[root@localhost ~]# ps aux | grep "vi" | grep -v "grep"
root 2313 0.0 0.2 7116 1544 pts/1 S+ 19:20 0:00 vi test.sh
\#换一个不同的终端，查看下这个这个进程的状态。进程状态是S（休眠）和+（位于后台），
\#因为是在另外一个终端运行的命令

[root@localhost ~]# kill -19 2313
\#使用- 19 信号，让PID是 2313 的进程暂停。相当于在vi界面按“ctrl+z”快捷键。

[root@localhost ~]# ps aux | grep "vi" | grep -v "grep"
root 2313 0.0 0.2 7116 1580 pts/1 T 19:20 0:00 vi test.sh
\#注意 2313 进程的状态，变成了T（暂停）状态。这时我切换回vi的终端，发现vi命令已
\#经暂停，又回到了命令提示符。
\#不过 2313 进程就会卡在后台，如果想要恢复可以使用“kill -9 2313”强制终止进程，也
\#可以利用15.2小节将要学习的工作管理来进行恢复。

2 ）、killall 命令
[root@localhost ~]# killall [选项][信号] 进程名
选项：
-i： 交互式，询问是否要杀死某个进程
-I： 忽略进程名的大小写

交互式杀死sshd进程
[root@localhost ~]# ps aux | grep "sshd" | grep -v "grep"
root 1733 0.0 0.1 8508 1008? Ss 19:47 0:00 /usr/sbin/sshd

云计算Linux课程系列
—————————————————————————————
root 1735 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/0
root 1758 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/1
\#查询系统有 3 个sshd进程。 1733 是sshd服务的进程， 1735 和 1758 是我的两个远程连接
\#的进程。

[root@localhost ~]# killall -i sshd
\#交互式杀死sshd进程
杀死 sshd(1733)? (y/N) n
\#这个进程是sshd的服务进程，如果杀死，所有的sshd连接都不能登录。
杀死 sshd(1735)? (y/N) n
\#这是我当前登录终端，不能杀死我自己吧！
杀死 sshd(1758)? (y/N) y
\#把另外一个sshd登录终端踢出。

3 ）、pkill 命令
pkill命令和killall命令非常类似，也是按照进程名来杀死进程。格式如下：
[root@localhost ~]# pkill [选项] [信号] 进程名
选项：
-t 终端号： 按照终端号踢出用户

[root@localhost ~]# pkill -9 -t pts/1
\#强制杀死从pts/1虚拟终端登录的进程

二、工作管理
1 工作管理简介
后台管理有几个事项需要大家注意：
 前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能
直接用ctrl+c来终止它，只能使用fg/bg来调用工作；
 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登
录的终端是不能管理tty2终端中的工作的；
 放入后台的命令必须可以持续运行一段时间，这样我们才能扑捉和操作这个工作。如果把ls
命令放入后台执行，它很快就会执行完成，我们很难操作它。
 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不
能执行。比如vi命令放入后台只能暂停，而不能执行，因为vi需要前台输入信息。top命
令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。

2 如何把命令放入后台
那么我们如何把命令放入后台呢？有两种方法，分别如下：

1)、 第一种方法是“命令 &”，把命令放入后台执行
第一种把命令放入后台的方法是在命令后面加入“空格&”，这种方法放入后台的命令，在后台
是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。
举个例子：

云计算Linux课程系列
—————————————————————————————
[root@localhost ~]# find / -name install.log &
[1] 1920

# [工作号] 进程号

\#find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进
\#程产生，所以也会有进程号。
这样的话，虽然find命令在执行，但是当前终端我还是可以进行其他命令操作的。如果在终端
上出现：
[1]+ Done find / -name install.log
证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[1]是
这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。

2)、 第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态
使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，
ctrl+z快捷键就是暂停的快捷键。举几个例子：
例 1 ：
[root@localhost ~]# top
\#在top命令执行的过程中，按下ctrl+z快捷键
[1]+ Stopped top
\#提示命令被放入后台，工作号是 1 ，状态是暂停。而且虽然top命令没有结束，也能取得
\#控制台权限。

例 2 ：
[root@localhost ~]# tar -zcf etc.tar.gz /etc
\#压缩一下/etc/目录
tar: 从成员名中删除开头的“/”
tar: 从硬连接目标中删除开头的“/”
^Z  执行的过程中，按下ctrl+z快捷键
[2]+ Stopped tar -zcf etc.tar.gz /etc
\#命令被放入后台，工作号是 2 ，状态是暂停。

3 后台命令管理
1)、 查看后台的工作
[root@localhost ~]# jobs [-l]
选项：
-l： 显示工作的PID

2 ）、 将后台暂停的工作恢复到前台执行
[root@localhost ~]# fg %工作号
参数：
%工作号： %号可以省略，但是注意工作号和 PID的区别

3 ）、 把后台暂停的工作恢复到后台执行

云计算Linux课程系列
—————————————————————————————
[root@localhost ~]# bg %工作号

4 ）、 后台命令脱离登录终端运行
我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远
程终端中执行了后台命令，这时我退出登录，这个后台命令还能继续执行吗？当然是不行的，这个后
台命令会被终止。但是我们确实需要在远程终端中执行某些后台命令，该如何执行呢？
 第一种方法是把需要后台执行的命令加入/etc/rc.local文件，让系统在启动时执行这个后
台程序。这种方法的问题是，服务器时不能随便重启的，万一有临时后台任务，就不能执行。
 第二种方法是使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的
命令与终端无关，是不依赖登录终端的。
 最后一种方法是使用nohup命令。
nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。命令的格式如
下：
[root@localhost ~]# nohup [命令] &

例如：
[root@localhost ~]# nohup find / -print > /root/file.log &
[3] 2349  用find命令，打印/下所有文件。放入后台执行
[root@localhost ~]# nohup: 忽略输入并把输出追加到"nohup.out"
\#有提示信息

三、系统资源查看

1 vmstat命令监控系统资源
[root@localhost ~]# vmstat [刷新延时 刷新次数]

例如：
[root@localhost proc]# vmstat 1 3
\#使用vmstat检测，每 1 秒刷新一次，共刷新 3 次
procs -----------memory---------- --- swap -- -----io---- --system-- -----cpu-----
r b swpd free buff cache si so bi bo in cs us sy id wa st
0 0 0 407376 55772 84644 0 0 5 2 9 10 0 0 100 0 0
0 0 0 407368 55772 84644 0 0 0 0 12 10 0 0 100 0 0
0 0 0 407368 55772 84644 0 0 0 0 15 13 0 0 100 0 0
解释下这个命令的输出：
 procs：进程信息字段：
 r：等待运行的进程数，数量越大，系统越繁忙。
 b：不可被唤醒的进程数量，数量越大，系统月繁忙。
 memory：内存信息字段：
 swpd：虚拟内存的使用情况，单位KB。
 free：空闲的内存容量，单位KB。
 buff：缓冲的内存容量，单位KB。
 cache：缓存的内存容量，单位KB。

云计算Linux课程系列
—————————————————————————————
 swap：交换分区的信息字段：
 si：从磁盘中交换到内存中数据的数量，单位KB。
 so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在
磁盘和内存之间交换，系统性能越差。
 io：磁盘读写信息字段：
 bi：从块设备读入数据的总量，单位是块。
 bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I/O越繁忙。
 system：系统信息字段：
 in：每秒被中断的进程次数。
 cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。
 CPU：CPU信息字段：
 us：非内核进程消耗CPU运算时间的百分比。
 sy：内核进程消耗CPU运算时间的百分比。
 id：空闲CPU的百分比。
 wa：等待I/O所消耗的CPU百分比。
 st：被虚拟机所盗用的CPU占比。

2 dmesg显示开机时内核检测信息
例如：
[root@localhost ~]# dmesg | grep CPU
\#查看CPU信息
[root@localhost ~]# dmesg | grep eth0
\#查询第一块网卡信息

3 free命令查看内存使用状态
[root@localhost ~]# free [-b|-k|- m|-g]
选项：
-b： 以字节为单位显示
-k： 以KB为单位显示，默认就是以KB为单位显示
-m： 以MB为单位显示
-g： 以GB为单位显示

[root@localhost ~]# free
total used free shared buffers cached
Mem: 625344 219704 405640 0 56852 85276
-/+ buffers/cache: 77576 547768
Swap: 524280 0 524280
解释下这个命令：
第一行：total是总内存数，used是已经使用的内存数，free是空闲的内存数，shared是多个
进程共享的内存总数，buffers是缓冲内存数，cached是缓存内存数。默认单位是KB。
第二行：-/buffers/cache的内存数，相当于第一行的used-buffers-cached。+/buffers/cache
的内存数，相当于第一行的free+buffers+cached。
第三行：total是swap的总数；used是已经使用的swap数，free是空闲的swap数。默认单位

云计算Linux课程系列
—————————————————————————————
是KB。

4 查看CPU信息
CPU的主要信息保存在/proc/cpuinfo这个文件当中，我们只要查看这个文件，就可以知道cpu
的相关信息。命令如下：
[root@localhost ~]# cat /proc/cpuinfo
processor : 0
\#逻辑CPU编号
vendor_id : GenuineIntel
\#CPU制造厂商
cpu family : 6
\#产品的系列代号
model : 58
\#CPU系列代号
model name : Intel(R) Core(TM) i7-3630QM CPU @ 2.40GHz
\#CPU系列的名字，编号，主频
stepping : 9
\#更新版本
cpu MHz : 2394.649
\#实际主频
cache size : 6144 KB
\#二级缓存

5 查看本机登陆用户信息
如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。
先看看w命令，命令格式如下：
[root@localhost ~]# w
09:54:22 up 9:50, 2 users, load average: 0.00, 0.00, 0.00
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
root tty1 - 09:53 57.00s 0.02s 0.02s -bash
root pts/0 192.168.0.108 09:53 0.00s 0.09s 0.06s w
解释下这个命令的结果：
 第一行其实和top命令的第一行非常类似，主要显示了系统当前时间，开机多久（up），有
多少用户登陆（users）， 1 分钟、 5 分钟、 15 分钟前的平均负载（load average）。
 第二行是项目的说明，第三行开始每行代表一个用户。这些项目是：
 USER：登陆的用户名；
 TTY：登陆终端；
 FROM：从哪个IP地址登陆；
 LOGIN@：登陆时间；
 IDLE：用户闲置时间；
 JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去
的后台作业时间，但却包括当前正在运行的后台作业所占用的时间；
 PCPU： 是指当前进程所占用的CPU运算时间；

云计算Linux课程系列
—————————————————————————————
 WHAT：当前正在运行的命令。

who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户。命令如下：
[root@localhost ~]# who
root tty1 2018-06-07 09:53
root pts/0 2018-06-07 09:53 (192.168.0.108)
\#用户名 登录终端 登录时间（登录来源IP地址）

6 uptime命令
uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行。其实w命令
也能看到这一行的数据，具体原意使用哪个命令看个人习惯。命令如下：
[root@localhost ~]# uptime
10:56:30 up 10:52, 2 users, load average: 0.00, 0.00, 0.00

7 查看系统与内核相关信息
我们使用uname命令查看内核的相关信息，命令如下：
[root@localhost ~]# uname [选项]
选项：
-a： 查看系统所有相关信息；
-r： 查看内核版本；
-s： 查看内核名称。

如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件（主要是系统命令）的
位数来推断系统的位数。命令如下：
[root@localhost ~]# file /bin/ls
/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses
shared libs), for GNU/Linux 2.6.18, stripped
\#很明显，当前系统是 32 位的。
如果我们想要查询当前Linux系统的发行版本，可以使用“lsb_release -a”命令查看，命令如
下：
[root@localhost ~]# lsb_release -a

四、系统定时任务
1 at一次性执行定时任务
1)、 at服务管理与访问控制
at命令要想正确执行，需要atd服务的支持。atd服务是独立的服务，所以启动的命令是：
[root@localhost ~]# service atd start
正在启动 atd： [确定]
如果想要让atd服务开机时自动启动，可以使用如下命令：
[root@localhost ~]# chkconfig atd on

atd服务启动之后，at命令才可以正常使用，不过我们还要学习下at命令的访问控制。这里的
访问控制指的是允许哪些用户使用at命令设定定时任务，或者不允许哪些用户使用at命令。大家可

云计算Linux课程系列
—————————————————————————————
以想象成为设定黑名单或设定白名单，这样更容易理解。at的访问控制是依靠/etc/at.allow文 件（ 白
名单）和/etc/at.deny文件（黑名单）这两个文件来实现的，具体规则如下：
 如果系统中有/etc/at.allow文件，那么只有写入/etc/at.allow文件（白名单）中的用户
可以使用at命令，其他用户不能使用at命令（/etc/at.deny文件会被忽略，也就是说同一
个用户既写入/etc/at.allow文件，也写入/etc/at.deny文件，那么这个用户是可以使用at
命令的，因为/etc/at.allow文件优先级更高。）。
 如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件，那么写入/etc/at.deny文件
（黑名单）中的用户不能使用at命令，其他用户可以使用at命令。不过这个文件对root
用户不生效。
 如果系统中这两个文件都不存在，那么只有root用户可以使用at命令。
系统中默认时只有/etc/at.deny文件，而且这个文件是空的，这样的话系统中所有的用户都可以
使用at命令。不过如果我们打算控制用户的at命令权限，把用户写入/etc/at.deny文件即可
/etc/at.allow 文件的权限更高，如果/etc/at.allow 文件存在，则/etc/at.deny 文件失效。
/etc/at.allow管理行为更加严格，因为只有写入这个文件的用户才能使用at命令，如果需要禁用
at命令的用户较多，则可以把少数用户写入这个文件。/etc/at.deny文件的管理较为松散，如果允
许使用at命令的用户较多，则可以把禁用的用户写入这个文件。不过这两个文件都不能对root用户
生效。

2 ）、 at命令
[root@localhost ~]# at [选项] 时间
选项：
-m： 当at工作完成后，无论是否命令有输出，都用email通知执行at
命令的用户
-c 工作号： 显示该at工作的实际内容
时间：
at支持的时间格式如下：
HH:MM 在指定的“小时:分钟”执行命令，例如：02:30
HH:MM YYYY-MM- DD 在指定的“小时:分钟 年-月-日”执行，例如02:30 2018-07-25
HH:MM[am|pm] [month] [date] 在指定的“小时:分钟[上午|下午][月][日]”执行，
例如02:30 July 25
HH:MM[am|pm] + [minutes|hours|days|weeks] 在指定的时间“再加多久执行”，例
如now + 5 minutes，05am +2 hours

at命令只要指定正确的时间，就可以输入需要在指定时间执行的命令了，这个命令可以是系统命
令，也可以是shell脚本。举几个例子吧：
例子 1 ：
[root@localhost ~]# cat /root/hello.sh
\#!/bin/bash
echo "hello world!!"
\#该脚本会打印“hello workd！！”

[root@localhost ~]# at now +2 minutes
at> /root/hello.sh >> /root/hello.log

云计算Linux课程系列
—————————————————————————————
\#执行hello.sh脚本，并把输出写入/root/hello.log文件
at> 使用ctrl+d保存at任务
job 8 at 2018-07-25 20:54 这是第 8 个at任务，会在 2018 年 7 月 25 日20:54
分执行

[root@localhost ~]# at -c 8
\#查询第 8 个at任务的内容
...省略部分内容... 主要是定义系统的环境变量
/root/hello.sh >> /root/hello.log
\#可以看到at执行的任务

例子 2 ：
[root@localhost ~]# at 02:00 2018-07- 26
at> /bin/sync
at> /sbin/shutdown -h now
at>
job 9 at 2018-07-26 02:00
\#在指定的时间关机。在一个at任务中，是可以执行多个系统命令的

3 ）、 其他at管理命令
at还有查询和删除命令，命令如下：
[root@localhost ~]# atq
\#查询当前服务器上的at工作

例如：
[root@localhost ~]# atq
9 2018-07-26 02:00 a root
\#说明root用户有一个at任务在 2018 年 7 月 26 日的02:00执行，工作号是 9

[root@localhost ~]# atrm [工作号]
\#删除指定的at任务

例如：
[root@localhost ~]# atrm 9
[root@localhost ~]# atq
\#删除 9 号at任务，再查询就没有at任务存在了

2 crontab循环执行定时任务
1 ）、 crond服务管理与访问控制
crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法
如下：
[root@localhost ~]# service crond restart
停止 crond： [确定]

云计算Linux课程系列
—————————————————————————————
正在启动 crond： [确定]
\#重启动crond服务

[root@localhost ~]# chkconfig crond on
\#设定crond服务为开机自启动
crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务
了。
crontab命令和at命令类似，也是通过/etc/cron.allow和/etc/cron.deny文件来限制某些用户
是否可以使用crontab命令的。而且原则也非常相似：
 当系统中有/etc/cron.allow文件时，只有希尔此文件的用户可以使用crontab命令，没有
写入的用户不能使用crontab命令。同样如果有此文件，/etc/cron.deny文件会被忽略，
/etc/cron.allow文件的优先级更高。
 当系统中只有/etc/cron.deny文件时，则写入此文件的用户不能使用crontab命令，没有写
入文件的用户可以使用crontab命令。
这个规则基本和at的规则一直，同样/etc/cron.allow文件的优先级比/etc/cron.deny文件的
优先级高，Linux中默认只有/etc/cron.deny文件。

2 ）、 用户的crontab设置
每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命
令即可，当然这个用户不能加入/etc/cron.deny文件中。crontab命令格式如下：
[root@localhost ~]# crontab [选项]
选项：
-e： 编辑crontab定时任务
-l： 查询crontab任务
-r： 删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可
以所以用“crontab -e”
-u 用户名： 修改或删除其他用户的crontab任务。只有root可用

[root@localhost ~]# crontab -e
\#进入crontab编辑界面。会打开vim编辑你的工作。

- - - - - 执行的任务

项目 含义 范围
第一个“*” 一小时当中的第几分钟 0-59
第二个“*” 一天当中的第几小时 0-23
第三个“*” 一个月当中的第几天 1-31
第四个“*” 一年当中的第几月 1-12
第五个“*” 一周当中的星期几 0-7（ 0 和 7 都代表星期日）
在时间表示时，还有一些特殊符号需要学习，如表15-8所示：
特殊符号 含义

- 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一
  次的意思。

云计算Linux课程系列
—————————————————————————————
， 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在
每天的 8 点 0 分， 12 点 0 分， 16 点 0 分都执行一次命令

- 代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一
  到周六的凌晨 5 点 0 分执行命令
  */n 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔
  10 分钟就执行一遍命令
  举例
  时间 含义
  45 22 * * * 命令 在 22 点 45 分执行命令
  0 17 * * 1 命令 每周 1 的 17 点 0 分执行命令
  0 5 1,15 * * 命令 每月 1 号和 15 号的凌晨 5 点 0 分执行命令
  40 4 * * 1-5 命令 每周一到周五的凌晨 4 点 40 分执行命令
  */10 4 * * * 命令 每天的凌晨 4 点，每隔 10 分钟执行一次命令
  0 0 1,15 * 1 命令 每月 1 号和 15 号，每周 1 的 0 点 0 分都会执
  行命令。注意：星期几和几号最好不要同时
  出现，因为他们定义的都是天。非常容易让
  管理员混乱。

例子 1 ：让系统每隔 5 分钟，就向/tmp/test文件中写入一行“ 11 ”，验证一下系统定时任务是否会
执行
[root@localhost ~]# crontab -e
\#进入编辑界面
*/5 * * * * /bin/echo ”11” >> /tmp/test
例子 2 ：在系统在每周二的凌晨 5 点 05 分重启一次
[root@localhost ~]# crontab -e
5 5 * * 2 /sbin/shutdown -r now
例子 3 ：在每月的 1 号， 10 号， 15 号的凌晨 3 点 30 分都定时执行日志备份脚本autobak.sh
[root@localhost ~]# crontab -e
30 3 1,10,15 * * /root/sh/autobak.sh
[root@localhost ~]# crontab -l
\#查看root用户的crontab任务
[root@localhost ~]# crontab -r
\#删除root用户所有的定时任务，如果只想删除某一个定时任务，
\#可以“crontab -e”进入编辑模式手工删除

3 ）、 crontab的注意事项
在书写crontab定时任务时，需要注意几个注意事项，这里我们再强调下：
 六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间；
 crontab定时任务，最小有效时间是分钟，最大时间范围是月。像 2018 年某时执行， 3 点 30
分 30 秒这样的时间都不能识别；
 在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天作为单位，
非常容易让管理员混乱；
 在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对

云计算Linux课程系列
—————————————————————————————
路径的命令会报错。
4 、 系统的crontab设置
“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可
是有些定时任务需要系统执行，这时我们就需要编辑/etc/crontab这个配置文件了。当然，并不是说
写入/etc/crontab配置文件中的定时任务执行时，不需要用户身份，而是“crontab -e”命令定义定
时任务时，默认用户身份是当前登录用户。而修改/etc/crontab配置文件时，定时任务的执行着身份
是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。
那我们打开这个文件看看吧：
[root@localhost ~]# vi /etc/crontab
SHELL=/bin/bash
\#标示使用哪种shell
PATH=/sbin:/bin:/usr/sbin:/usr/bin
\#指定PATH环境变量，crontab是使用自己的PATH，而不是用系统默认的，所以在定时任务中出现的命令最好使用大
写
MAILTO=root
\#如果有报错输出，或命令结果又输出，会向root发信息
HOME=/
\#标示主目录

# For details see man 4 crontabs

\#提示大家可以去“man 4 crontabs”查看帮助

# Example of job definition:

# .---------------- minute (0 - 59)

# | .------------- hour (0 - 23)

# | | .---------- day of month (1 - 31)

# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...

# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat

# | | | | |

# * * * * * user-name command to be executed

\#分 时 日 月 周 执行者身份 命令
\#列出文件格式，并加入了注释
在CentOS 6.x中，/etc/crontab这个文件也发生了变化，在CentOS 5.x中这个文件的内容大概
是这个样子：
\#以下输出，是在CentOS 5.5当中
[root@sc ~]# vi /etc/crontab
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/

# run-parts

01 * * * * root run-parts /etc/cron.hourly

云计算Linux课程系列
—————————————————————————————
02 4 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
在 CentOS 5.x 版本中， /etc/crontab 文件会使用 run-parts 脚本执行
/etc/cron.{daily,weekly,monthly}目录中的所有文件。这个run-parts其实是一个shell脚本，保
存在/usr/bin/run-parts，它的作用就是把其后面跟随的目录中的所有可执行文件依次执行。也就是
说，如果我们想让某个脚本在每天都执行一次，可以不用手工去写定时任务，而只需要给这个脚本赋
予执行权限，并把它放入/etc/cron.daily/目录中。这样这个脚本就会在每天的凌晨 4 点 02 分执行
了。
可是在CentOS 6.x版本中，/etc/crontab文件中不再有相关的段落，那么是否run- ptars这种
定时任务执行方法不可用了呢？我们看到/etc/crontab中有一句提示，让我们“man 4 crontabs”来
查看帮助，那么我们就看看这个帮助吧！在这个帮助中，明确写明了“在旧版本的crontab配置文件
中，是通过run -parts脚本来调用cron.{daily,weekly,monthly}目录，定时执行这些目录中的脚本。
在当前系统中，为了避免cron和anacron之间产生冲突，只要anacron已经安装，就使用anacron
来执行这些目录中的脚本。具体可以查看anacron（ 8 ）的帮助。”。对于anacron的用法，我们下一
个小节来介绍。
其实对我们用户来讲，我们并不需要知道这个定时任务到底是由哪个程序调用的。我们需要知道
的事情是如何使用系统的crontab设置。这个新老版本的CentOS没有区别，配置方法都有两种：
 第一种方法就是我刚刚说过的，把你需要定时执行的工作写成脚本程序，并赋予执行权限，
然后直接把这个脚本复制到/etc/cron.{daily,weekly,monthly}目录中的任意一个。比如我
需要让某个脚本每周执行，那么就把这个脚本复制到/etc/cron.weekly/目中中。这样这个
脚本就会每周执行一次，具体的执行时间要参考anacron的配置。
 第二种方法就是修改/etc/crontab这个配置文件，自己加入自己的定时任务，不过需要注意
指定脚本的执行者身份。例如：
[root@localhost ~]# vi /etc/crontab
...省略部分输出...

- - - - - root run-parts /root/cron/
          \#让系统每分钟都执行一次/root/cron/目录中的脚本，脚本执行者是root用户。
          \#虽然在CentOS 6.x中，不是直接通过此配置文件调用/etc/cron.{daily,weekly,monthly}这些目录，
          \#但是run- parts脚本还是可以使用的。所以我完全可以参照CentOS 5.x的方法来写定时任务。
          \#使用run- parts脚本调用并执行/root/cron/目录中所有的可执行文件

[root@localhost ~]# mkdir cron
\#建立/root/cron目录
[root@localhost cron]# vi /root/cron/hello.sh
\#/bin/bash
echo "hello" >> /root/cron/hello.log
\#在/root/cron/hello.log文件中写入hello
[root@localhost cron]# chmod 755 hello.sh
\#赋予执行权限。
\#因为hello.sh脚本放入了/root/cron/目录，所以会每分钟执行一次。
只要保存/etc/crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。
这两种方法都是可以使用的，具体看个人的习惯吧！不过要想修改/etc/crontab文件，当然我要

云计算Linux课程系列
—————————————————————————————
是root用户才可以，普通不能修改，只能使用用户身份的crontab命令。

3 anacron
anacron是用来干什么的呢？我们的Linux服务器如果不是 24 小时开机的，那么刚好在关机的时
间段之内有系统定时任务（cron）需要执行，那么这些定时任务是不会执行的。也就是说，假设我们
需要在凌晨 5 点 05 分执行系统的日志备份，但是我们的Linux服务器不是 24 小时开机的，在晚上需
要关机，白天上班之后才会再次开机。这个定时任务的执行时间我们的服务器刚好没有开机，那么这
个任务就不会执行了。anacron就是用来解决这个问题的。
anacron会使用一天，七天，一个月作为检测周期，用来判断是否有定时任务在关机之后没有执
行，如果有这样的任务，anacron会在特定的时间重新执行这些定时任务。那么anacron是如何判断
这些定时任务已经超过了执行时间呢？在系统的/var/spool/anacron/目录中存在
cron.{daily,weekly,monthly}文件，这些文件中都保存着anacron上次执行时的时间。anacron会去
读取这些文件中的时间，然后和当前时间做比较，若果两个时间的差值超过了anacron的指定时间差
值（一般是 1 天， 7 天和一个月），就说明有定时任务漏掉了没有被执行，这时anacron会介入而执
行这个漏掉的定时任务，从而保证在关机时没有被执行的定时任务不会被漏掉。
在CentOS 6.x中，我们使用cronie-anacron取代了vixie-cron软件包。而且在原先的CentOS
版本中/etc/cron.{daily,weekly,monthly}这些目录中的定时任务会同时被cron和anacron调用，
这样非常容易出现重复执行同一个定时任务的错误。在现在的 CentOS 6.x 中，
/etc/cron.{daily,weekly,monthly}目录中的定时任务程序只会被anacron调用，从而保证这些定时
任务只会在每天、每周或每月被定时执行一次，而不会重复执行。这也是我们在上一个小节中介绍的
CentOS 6.x的变化之一。
在CentOS 6.x中anacron还有一个变化，anacron不再是单独的服务，而变成了系统命令。也就
是说我们不再可以使用“service anacron restart”命令来管理anacron服务了。而是需要使用anacron
命令来管理anacron工作，具体命令如下：
[root@localhost ~]# anacron [选项] [工作名]
选项：
-s： 开始anacron工作，依据/etc/anacrontab文件中的设定的延迟时间执行
-n： 立即执行/etc/anacrontab中所有的工作，忽略所有的延迟时间
-u： 更新/var/spool/anacron/cron.{daily,weekly,monthly}文件中的时间戳，但
不执行任何工作
参数：
工作名： 是依据/etc/anacrontab文件中定义的工作名
在我们当前的Li nux中，其实不需要执行任何anacron命令，只需要配置好/etc/anacrontab文
件，系统就会依赖这个文件中的设定来通过anacron执行定时任务。那么关键就是/etc/anacrontab
文件的内容了，这个文件如下：
[root@localhost ~]# vi /etc/anacrontab

# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

云计算Linux课程系列
—————————————————————————————
\#前面的内容和/etc/crontab类似

# the maximal random delay added to the base delay of the jobs

RANDOM_DELAY=45
\#最大随机延迟。

# the jobs will be started during the following hours only

START_HOURS_RANGE=3-22
\#anacron的执行时间范围是3:00-22:00

\#period in days delay in minutes job-identifier command
1 5 cron.daily nice run-parts /etc/cron.daily
7 25 cron.weekly nice run-parts /etc/cron.weekly
@monthly 45 cron.monthly nice run-parts /etc/cron.monthly
\#天数 强制延迟（分） 工作名称 实际执行的命令
\#时间差超过天数时，强制延迟多少分钟之后，就执行命令
这个文件中“RANDOM_DELAY”定义的是最大随机延迟，也就是说cron.daily任务如果超过 1 天
没有执行，并不会马上执行，而是先延迟强制延迟时间之后，再延迟随机延迟时间之后再执行命令。
“START_HOURS_RANGE”定义anacron的执行时间范围，anacron只会在这个时间范围之内执行。
我们用cron.daily工作来说明下/etc/anacrontab的执行过程：
 首先读取/var/spool/anacron/cron.daily中的上一次anacron执行的时间；
 和当前时间比较，如果两个时间的差值超过 1 天，就执行cron.daily工作；
 执行这个工作只能在03:00-22:00之间；
 执行工作时强制延迟时间为 5 分钟，再随机延迟0-45分钟时间；
 使用nice命令指定默认优先级，使用run- parts脚本执行/etc/cron.daily目录中的所有可
执行文件。
大家发现了吧，/etc/cron.{daily,weekly,monthly}中的脚本，在当前的Linux中是被anacron
调用的，不再依靠cron服务。不过anacron不用设置多余的配置，我们只需要把需要定时执行的脚
本放入/etc/cron.{daily,weekly,monthly}目录当中，就会每天、每周或每月执行，而且也不再需要
启动anacron服务了。我们如果做修改的话，只用修改/etc/anacrontab配置文件即可。比如我更加
习惯让定时任务在凌晨03:00-05:00执行，就可以如下修改：
[root@localhost ~]# vi /etc/anacrontab

# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# the maximal random delay added to the base delay of the jobs

RANDOM_DELAY=0
\#随机延迟改为 0 分钟，不再随机延迟

# the jobs will be started during the following hours only

START_HOURS_RANGE=3-5

云计算Linux课程系列
—————————————————————————————
\#执行时间范围为03:00-05:00

\#period in days delay in minutes job-identifier command
1 0 cron.daily nice run-parts /etc/cron.daily
7 0 cron.weekly nice run-parts /etc/cron.weekly
@monthly 0 cron.monthly nice run-parts /etc/cron.monthly
\#强制延迟也改为 0 分钟，不再强制延迟
这样我们所有放入/etc/cron.{daily,weekly,monthly}目录中的脚本都会在指定时间运行了，而
且也不怕服务器万一关机的情况了。

云计算Linux课程系列
—————————————————————————————

第十六章：日志管理

```
尚硅谷云计算Linux课程
```

版本：V1. 0
讲师：沈超

一、日志简介
1 日志相关服务
在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已
经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：
 基于TCP网络协议传输日志信息；
 更安全的网络传输方式；
 有日志消息的及时分析框架；
 后台数据库；
 配置文件中可以写简单的逻辑判断；
 与syslog配置文件相兼容。

2 系统中常见的日志文件
日志文件 说 明
/var/log/cron 记录了系统定时任务相关的日志。
/var/log/cups/ 记录打印信息的日志
/var/log/dmesg 记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查
看内核自检信息。
/var/log/btmp 记录错误登录的日志。这个文件是二进制文件，不能直接vi查看，
而要使用lastb命令查看，命令如下：
[root@localhost log]# lastb
root tty1 Tue Jun 4 22:38 - 22:38 (00:00)
\#有人在 6 月 4 日22:38使用root用户，在本地终端 1 登录错误
/var/log/lastlog 记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进
制文件，不能直接vi，而要使用lastlog命令查看。
/var/log/mailog 记录邮件信息。
/var/log/message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大
多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日
志文件。
/var/log/secure 记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。
比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添
加用户和修改用户密码都会记录在这个日志文件中。
/var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、
关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需
要使用last命令来查看。

云计算Linux课程系列
—————————————————————————————
/var/run/utmp 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销
而不断变化，只记录当前登录用户的信息。同样这个文件不能直接
vi，而要使用w，who，users等命令来查询。

除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在/var/log/目录
中（源码包安装的服务日志是在源码包指定目录中）。不过这些日志不是由rsyslogd服务来记录和
管理的，而是各个服务使用自己的日志管理文档来记录自身日志。
日志文件 说 明
/var/log/httpd/ RPM包安装的apache服务的默认日志目录
/var/log/mail/ RPM包安装的邮件服务的额外日志目录
/var/log/samba/ RPM包安装的samba服务的日志目录
/var/log/sssd/ 守护进程安全服务目录

二、日志服务rsyslogd
1 日志文件格式
只要是由日志服务rsyslogd记录的日志文件，他们的格式是一样的。基本日志格式包含以下四
列：
 事件产生的时间；
 发生事件的服务器的主机名；
 产生事件的服务名或程序名；
 事件的具体信息。

2 rsyslogd服务的配置文件
1 ）、 /etc/rsyslog.conf配置文件格式
authpriv.* /var/log/secure
\#服务名称[连接符号]日志等级 日志记录位置
\#认证相关服务.所有日志等级 记录在/var/log/secure日志中
 服务名称
那么我们首先需要确定rsyslogd服务可以识别哪些服务的日志，也可以理解为以下这些服务委
托了rsyslogd服务来代为管理日志。这些服务如表16-3所示：
服务名称 说 明
auth（LOG_AUTH） 安全和认证相关消息（不推荐使用authpriv替代）
authpriv（LOG_AUTHPRIV） 安全和认证相关消息（私有的）
cron（LOG_CRON） 系统定时任务cront和at产生的日志
daemon（LOG_DAEMON） 和各个守护进程相关的日志
ftp（LOG_FTP） ftp守护进程产生的日志
kern（LOG_KERN） 内核产生的日志（不是用户进程产生的）
local0-local7（LOG_LOCAL0-7） 为本地使用预留的服务
lpr（LOG_LPR） 打印产生的日志
mail（LOG_MAIL） 邮件收发信息
news（LOG_NEWS） 与新闻服务器相关的日志
syslog（LOG_SYSLOG） 有syslogd服务产生的日志信息（虽然服务名称已经改为

云计算Linux课程系列
—————————————————————————————
rsyslogd，但是很多配置都还是沿用了syslogd的，这里
并没有修改服务名）。
user（LOG_USER） 用户等级类别的日志信息
uucp（LOG_UUCP） uucp子系统的日志信息，uucp是早期linux系统进行数
据传递的协议，后来也常用在新闻组服务中。

 连接符号
日志服务连接日志等级的格式是：
日志服务[连接符号]日志等级 日志记录位置
在这里连接符号可以识别为：
 “.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如：“cron.info”
代表cron服务产生的日志，只要日志等级大于等于info级别，就记录
 “.=”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.=emerg”代表任
何日志服务产生的日志，只要等级是emerg等级就记录。这种用法及少见，了解就好
 “.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。

 日志等级
 等 级 名 称 说 明
debug（LOG_DEBUG） 一般的调试信息说明
info（LOG_INFO） 基本的通知信息
notice（LOG_NOTICE） 普通信息，但是有一定的重要性
warning（LOG_WARNING） 警告信息，但是还不回影响到服务或系统的运行
err（LOG_ERR） 错误信息，一般达到err等级的信息以及可以影响到服务或系
统的运行了。
crit（LOG_CRIT） 临界状况信息，比err等级还要严重
alert（LOG_ALERT） 警告状态信息，比crit还要严重。必须立即采取行动
emerg（LOG_EMERG） 疼痛等级信息，系统已经无法使用了

- 代表所有日志等级，比如：“authpriv.*”代表authpriv认
  证信息服务产生的日志，所有的日志等级都记录
  表16- 4 日志等级
  日志等级这里还可以识别“none”，如果日志等级是none，就说明忽略这个日志服务，该服务的
  所有日志都不再记录。

 日志记录位置
日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到打印机打印，
或者输出到远程日志服务器上（当然日志服务器要允许接收才行）。日志的记录位置也是固定的，我
们来学习下：
 日志文件的绝对路径。这是最常见的日志保存方法，如“/var/log/secure”就是保存
系统验证和授权信息日志的。
 系统设备文件。如“/dev/lp0”代表第一台打印机，如果日志保存位置是打印机设备的
话，当有日志时就会在打印机打印（不太符合可持续发展战略哦-_-!）。
 转发给远程主机。因为可以选择使用TCP协议和UDP协议传输日志信息，所以有两种发

云计算Linux课程系列
—————————————————————————————
送格式。如使用“@192.168.0.210:514”，就会把日志内容使用 UDP 协议发送到
192.168.0.210的UDP 514端口上；如果使用“@@192.168.0.210:514”就会把日志内容
使用TCP协议发送到192.168.0.210的TCP 514端口上，其中 514 是日志服务默认端口。
当然只要192.168.0.210同意接收此日志，就可以把日志内容保存在日志服务器上。
 用户名。如“root”，就会把日志发送给root用户，当然root要在在线，否则就收不
到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.*
*”就会把mail服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送
给多个在线用户，用户名之间用“，”分隔。
忽略或丢弃日志。如果接受日志的对象是“~”，代表这个日志不会记录，而被直接丢弃。如“local3.*
~”代表忽略local3服务类型所有的日志都不记录。

2 ）、 /etc/rsyslog.conf配置文件的内容
[root@localhost ~]# vi /etc/rsyslog.conf
\#查看配置文件的内容

# rsyslog v5 configuration file

# For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html

# If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html

#### MODULES

\#加载模块

$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
\#加载imuxsock模块，为本地系统登录提供支持
$ModLoad imklog # provides kernel logging support (previously done by rklogd)
\#加载imklog模块，为内核登录提供支持
\#$ModLoad immark # provides --MARK-- message capability
\#加载immark模块，提供标记信息的能力

# Provides UDP syslog reception

\#$ModLoad imudp
\#$UDPServerRun 514
\#加载UPD模块，允许使用UDP的 514 端口接收采用UDP协议转发的日志

# Provides TCP syslog reception

\#$ModLoad imtcp
\#$InputTCPServerRun 514
\#加载TCP模块，允许使用TCP的 514 端口接收采用TCP协议转发的日志

#### GLOBAL DIRECTIVES

\#定义全局设置

# Use default timestamp format

云计算Linux课程系列
—————————————————————————————
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
\#定义日志的时间使用默认的时间戳格式

# File syncing capability is disabled by default. This feature is usually not required,

# not useful and an extreme performance hit

\#$ActionFileEnableSync on
\#文件同步功能。默认没有开启，是注释的。

# Include all config files in /etc/rsyslog.d/

$IncludeConfig /etc/rsyslog.d/*.conf
\#包含/etc/rsyslog.d/目录中所有的“.conf”子配置文件。也就是说这个目录中的所有
\#子配置文件也同时生效。

#### RULES

\#日志文件保存规则

# Log all kernel messages to the console.

# Logging much else clutters up the screen.

\#kern.* /dev/console
\#kern服务.所有日志级别 保存在/dev/console
\#这个日志默认没有开启，如果需要，则取消注释

# Log anything (except mail) of level info or higher.

# Don't log private authentication messages!

*.info;mail.none;authpriv.none;cron.none /var/log/messages
\#所有服务.info以上级别的日志保存在/var/log/messages日志中。
\#mail，authpriv，cron的日志不记录在/var/log/messages日志文件中，因为它们都有自己的日志文件。
\#所以/var/log/messages日志是最重要的系统日志文件，需要经常查看！

# The authpriv file has restricted access.

authpriv.* /var/log/secure
\#用户认证服务所有级别的日志保存在/var/log/secure日志中

# Log all the mail messages in one place.

mail.* -/var/log/maillog
\#mail服务的所有级别的日志保存在/var/log/maillog日志中。
\#“-”号的含义是日志先在内存之中保存，当日志够多之后，再向文件中保存。

# Log cron stuff

cron.* /var/log/cron
\#计划任务的所有日志保存在/var/log/cron日志中

云计算Linux课程系列
—————————————————————————————

# Everybody gets emergency messages

*.emerg *
\#所有日志服务的疼痛等级日志对所有在线用户广播。

# Save news errors of level crit and higher in a special file.

uucp,news.crit /var/log/spooler
\#uucp和news日志服务的crit以上的日志保存在/var/log/sppoler日志文件中。

# Save boot messages also to boot.log

local7.* /var/log/boot.log
\#loacl7日志服务的所有日志写入/var/log/boot.log日志中。
\#会把开机时的检测信息在显示到屏幕的同时，写入/var/log/boot.log日志中

# ### begin forwarding rule

\#定义转发规则

# The statement between the begin ... end define a SINGLE forwarding

# rule. They belong together, do NOT split them. If you create multiple

# forwarding rules, duplicate the whole block!

# Remote Logging (we use TCP for reliable delivery)

# 

# An on-disk queue is created for this action. If the remote host is

# down, messages are spooled to disk and sent when it is up again.

\#$WorkDirectory /var/lib/rsyslog # where to place spool files
\#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
\#$ActionQueueMaxDiskSpace 1g # 1gb space limit (use as much as possible)
\#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
\#$ActionQueueType LinkedList # run asynchronously
\#$ActionResumeRetryCount -1 # infinite retries if host is down

# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional

\#*.* @@remote-host:514

# ### end of the forwarding rule

3)、 定义自己的日志
[root@localhost ~]# vi /etc/rsyslog.conf
\#写入一下一句话
*.crit /var/log/alert.log
\#把所有服务的“临界点”以上的错误都保存在/var/log/alert.log日志中

[root@localhost ~]# service rsyslog restart
关闭系统日志记录器： [确定]
启动系统日志记录器： [确定]
\#重启rsyslog服务
[root@localhost ~]# ll /var/log/alert.log

云计算Linux课程系列
—————————————————————————————
-rw-------. 1 root root 0 6月 5 10:33 /var/log/alert.log

# alert.log日志就生成了

三、日志轮替

1 日志文件的命名规则
日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文
件超出保存的范围之后，就会进行删除。那么旧的日志文件改名之后，如何命名呢？主要依靠
/etc/logrotate.conf配置文件中“dateext”参数：
 如果配置文件中拥有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如
“secure-20180605”。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，
只需要保存指定的日志个数，删除多余的日志文件即可。
 如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日
志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，
用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，
当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保
存新的日志，以此类推。

2 logrotate配置文件
[root@localhost ~]# vi /etc/logrotate.conf

# see "man logrotate" for details

# rotate log files weekly

weekly
\#每周对日志文件进行一次轮替

# keep 4 weeks worth of backlogs

rotate 4
\#保存 4 个日志文件，也就是说如果进行了 5 次日志轮替，就会删除第一个备份日志

# create new (empty) log files after rotating old ones

create
\#在日志轮替时，自动创建新的日志文件

# use date as a suffix of the rotated file

dateext
\#使用日期作为日志轮替文件的后缀

# uncomment this if you want your log files compressed

\#compress
\#日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩

\#以上日志日志配置为默认配置，如果需要轮替的日志没有设定独立的参数，那么都会遵守以上参数。
\#如果轮替日志配置了独立参数，那么独立参数优先级更高。

云计算Linux课程系列
—————————————————————————————

# RPM packages drop log rotation information into this directory

include /etc/logrotate.d
\#包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，
\#进行日志轮替。

# no packages own wtmp and btmp -- we'll rotate them here

\#以下两个轮替日志有自己的独立参数，如果和默认的参数冲突，则独立参数生效。
/var/log/wtmp {
\#以下参数仅对此目录有效
monthly
\#每月对日志文件进行一次轮替
create 0664 root utmp
\#建立的新日志文件，权限是 0664 ，所有者是root，所属组是utmp组
minsize 1M
\#日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算
\#时间达到一个月，也不进行日志转储
rotate 1
\#仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已
}

/var/log/btmp {
\#以下参数只对/var/log/btmp生效
missingok
\#如果日志不存在，则忽略该日志的警告信息
monthly
create 0600 root utmp
rotate 1
}

# system-specific logs may be also be configured here.

logrotate配置文件的主要参数，我们通过表16- 4来说明下：
参 数 参 数 说 明
daily 日志的轮替周期是每天
weekly 日志的轮替周期是每周
monthly 日志的轮替周期是每月
rotate 数字 保留的日志文件的个数。 0 指没有备份
compress 日志轮替时，旧的日志进行压缩
create mode owner group 建立新日志，同时指定新日志的权限与所有者和所属组。如
create 0600 root utmp
mail address 当日志轮替时，输出内容通过邮件发送到指定的邮件地址。如
mail shenc@lamp.net
missingok 如果日志不存在，则忽略该日志的警告信息

云计算Linux课程系列
—————————————————————————————
notifempty 如果日志为空文件，则不进行日志轮替
minsize 大小 日志轮替的最小值。也就是日志一定要达到这个最小值才会轮
替，否则就算时间达到也不轮替
size 大小 日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。
如size 100k
dateext 使用日期作为日志轮替文件的后缀。如secure-2018 0605
sharedscripts 在此关键字之后的脚本只执行一次
prerotate/endscript 在日志轮替之前执行脚本命令。endscript标示prerotate脚本
结束。
postrotate/endscript 在日志轮替之后执行脚本命令。endscript标示postrotate脚
本结束
这些参数中较为不好理解的应该就是prerotate/endscript和postrotate/endscript参数了，
我们利用“man logrotate”中的列子来解释下这两个参数。例如：
"/var/log/httpd/access.log" /var/log/httpd/error.log {
\#日志轮替的是/var/log/httpd/中RPM包安装的apache正确访问日志和错误日志
rotate 5
\#轮替 5 次
mail www@my.org
\#信息发送到指定邮箱
size 100k
\#日志大于100KB时才进行日志轮替，不再按照时间轮替
sharedscripts
\#以下脚本只执行一次
postrotate
\#在日志轮替结束之后，执行以下脚本
/usr/bin/killall -HUP httpd
\#重启apache服务
endscript
\#脚本结束
}
prerotate和postrotate主要用于在日志轮替的同时，执行指定的脚本，一般用于日志轮替之后
重启服务。这里强调，如果你的日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate
后，一定要重启rsyslog服务，否则你会发现虽然新日志建立了，但是数据还是写入了旧的日志当中。
那是因为虽然logrotate知道日志轮替了，但是rsyslog服务却并不知道。同理，如果你的日志不是
被rsyslog管理，如源码包安装的Apache、Nginx等服务，则需要重启Apache或Nginx服务，否则
日志也不能正常轮替。

3 把自己的日志加入日志轮替
这里有两个方法：第一种方法是直接在/etc/logrotate.conf配置文件中写入该日志的轮替策略，
从而把日志加入轮替；第二种方法是在/etc/logrotate.d/目录中新建立该日志的轮替文件，在该轮
替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可
以把日志加入轮替。我们这里推荐第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写
入/etc/logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。

云计算Linux课程系列
—————————————————————————————
说起来很复杂，我们举个例子吧，还记得我们自己生产的/var/log/alert.log日志吗？这个日志
不是系统默认日志，而是我们通过/etc/rsyslog.conf配置文件自己生成的日志，所以默认这个日志
是不会轮替的。那么我们需要把这个日志加入日志轮替的策略，该怎么实现呢？我们采用第二种方法，
也就是在/etc/logrotate.d/目录中建立此日志的轮替文件。具体步骤如下：
[root@localhost ~]# chattr +a /var/log/alert.log
\#先给日志文件赋予chattr的a属性，保证日志的安全
[root@localhost ~]# vi /etc/logrotate.d/alter
\#创建alter轮替文件，把/var/log/alert.log加入轮替
/var/log/alert.log {
weekly 每周轮替一次
rotate 6 保留 6 个轮替日志
sharedscripts 以下命令只执行一次
prerotate 在日志轮替之前执行
/usr/bin/chattr -a /var/log/alert.log
\#在日志轮替之前取消a属性，以便让日志可以轮替
endscript 脚本结束

sharedscripts
postrotate 在日志轮替之后执行
/usr/bin/chattr +a /var/log/alert.log
\#日志轮替之后，重新加入a属性
endscript

sharedscripts
postrotate
/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid 2>/dev/null) &>/dev/null
endscript
\#重启rsyslog服务，保证日志轮替正常
}
再举个例子，我们如果需要把Nginx服务的日志加入日志轮替，则也需要重启Nginx服务，例如：
/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log {
\#假设Nginx的日志放在/date目录下
daily
rotate 15
sharedscripts
postrotate
/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &>/dev/null
\#重启rsyslog服务
/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &>/dev/null
\#重启Nginx服务
endscript
}

云计算Linux课程系列
—————————————————————————————
4 logrotate命令
我们日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记得
/etc/cron.daily/目录，就会发现这个目录中是有logrotate文件，logrotate通过这个文件依赖定
时任务执行的。
不过logrotate命令的格式是什么样的呢？我们来学习下：
[root@localhost ~]# logrotate [选项] 配置文件名
选项：
如果此命令没有选项，则会按照配置文件中的条件进行日志轮替
-v： 显示日志轮替过程。加了-v选项，会显示日志的轮替的过程
-f： 强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有
的日志进行轮替
我们执行logrotate命令，并查看下执行过程：
[root@localhost ~]# logrotate -v /etc/logrotate.conf
\#查看日志轮替的流程
...省略部分输出...
rotating pattern: /var/log/alert.log weekly (6 rotations)
\#这就是我们自己加入轮替的alert.log日志。
empty log files are rotated, old logs are removed
considering log /var/log/alert.log
log does not need rotating 时间不够一周，所以不进行日志轮替
...省略部分输出...
我们发现/var/log/alert.log加入了日志轮替，已经被logrotate识别，并调用了。只是时间没
有达到轮替的标准，所以没有进行轮替。那我们强制进行一次日志轮替，看看有什么结果：
[root@localhost ~]# logrotate -vf /etc/logrotate.conf
\#强制进行日志轮替，不管是否符合轮替条件
...省略部分输出...
rotating pattern: /var/log/alert.log forced from command line (6 rotations)
empty log files are rotated, old logs are removed
considering log /var/log/alert.log
log needs rotating 日志需要轮替
rotating log /var/log/alert.log, log->rotateCount is 6
dateext suffix '-20180607' 提取日期参数
glob pattern '-[0- 9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
glob finding old rotated logs failed
running prerotate script
fscreate context set to unconfined_u:object_r:var_log_t:s0
renaming /var/log/alert.log to /var/log/alert.log-20180607
\#旧的日志被重命名
creating new /var/log/alert.log mode = 0600 uid = 0 gid = 0
\#创建新日志文件，同时制定权限、所有者和属组
running postrotate script
...省略部分输出...
我们发现alert.log日志已经完成了日志轮替。我们查看下新产生的日志和旧日志：
[root@localhost ~]# ll /var/log/alert.log*
-rw-------. 1 root root 0 6月 7 10:07 /var/log/alert.log
-rw-------. 1 root root 237 6月 7 09:58 /var/log/alert.log-20180607
\#旧日志文件已经转储
[root@localhost ~]# lsattr /var/log/alert.log
-----a-------e- /var/log/alert.log
\#新的日志文件被自动加入了chattr的a属性。
logrotate命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有
的日志都进行了轮替。
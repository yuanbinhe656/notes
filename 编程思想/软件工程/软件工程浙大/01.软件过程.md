1. 规则是为了是总目标完成的更方便，如果设置的规则损害了该目标该规则不好
2. 总体设计方法
   1. 先对实际模型进行观察，进行主观和客观认识
   2. 将实际模型抽象
   3. 选择合适的解决方法
   4. 选择具体的策略（编程语言…）
3. 通用流程框架
   1. 工作任务
   2. 工作产品
   3. 里程碑和可交付成果（可以是阶段产出）
   4. 质量检测
   5. 保护伞工作（贯穿流程始终）
      1. 项目管理质量保证
      2. 工作产品生产
      3. 正式技术审批
      4. 配置管理
      5. 可重用性管理
      6. 风险管理
      7. 测量
4. 具体框架流程
   1. 沟通（客户协作和需求收集）
   2. 规划（建立工程工作计划，描述技术风险，列出资源需求，生产的工作产品，定义工作速度）
   3. 建模（创建模型以帮助开发人员和客户了解需求和软件设计）
   4. 构建（代码生成和测试）
   5. 部署（交付用于客户评估和反馈的软件）
5. 文档作用：
   1. 主要不是给自己看的，是给别人沟通看的，具有不实时性
   2. 设计全产品统一
6. 能力成熟度模型CMI
   1. 作用：进行软件公司能力评级
   2. 评级程度
      1. 0级，不完整（过程未执行或未实现此级别定义的所有目标）
      2. 1级，执行（生产所需工作产品所需的工作任务能够执行）
      3. 2级，管理（工作人员可以获得足够的资源来完成工作，利益相关者积极参与。工作任务和产品被监控，修订和评估以符合过程描述）
      4. 3级，定义（管理和工程过程文件化，标准化，并集成到整个组织的软件过程中）
      5. 4级，定量管理（软件过程和产品得到定量的理解和控制，使用定量的措施）
7. 模型
   1. 一般前人经验，具有经验性
   2. 效率高，在某一方面，或者综合
   3. 个人模型：
      1. 规划
      2. 高层次设计
      3. 高级设计评审
      4. 发展
      5. 对于失败进行深刻剖析原因（如copy一行导致一个字母少复制，造成错误，找深层次的原因，比如休息不好或者键盘鼠标不合适。）
8. 常见模型
   1. 瀑布模型（最古老，不允许回头）
      1. 缺点：
         1. 死板
         2. 不真实
         3. 只在最后才能看到产出结果，前期只能看文档
      2. 其他模型基本上是其变形
   2. 增量模型
      1. 前期设计核心功能，然后发布，后续进行功能的增加，依次迭代。
      2. 优点：
         1. 前期可见，能较好的占领市场
         2. 效率高
   3. 快速开发模型
      1. 分成模块，每个模块齐头并进，效率高
      2. 缺点：
         1. 人数需要多，需要较好和客户反应
         2. 模块需要尽可能独立
         3. 技术风险高不适合
   4. 螺旋模型
      1. 分为四个阶段：
         1. 设计
         2. 评估分析
         3. 反馈
         4. 实现+新一轮规划
   5. 演化试
      1. 做一个样机，类似模型，一个空壳，收集客户反馈（图形化），快，尽可能得到准确需求
   6. 并发
      1. 一个网络
9. 相关思路
   1. 软件改进不单单要考虑对客户的影响，还要考虑改进对于自己来说所花费的成本
   2. 先动脑再动手
   3. 为客户和用户提供价值
   4. kiss——保持其简单，尽可能从简单的角度考虑，不需要太复杂，保持愚蠢
   5. 你生产什么别人就消费什么
   6. 更易于未来的更新和维护
10. 软件工程实践
    1. 沟通实践
    2. 规划事务
    3. 建模实践
       1. 分析
       2. 设计
    4. 建筑实践
       1. 译码
       2. 测试
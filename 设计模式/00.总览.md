### 01设计模式基础

1. 抽象
2. 封装：隐藏内部实现
3. 多态：改写对象行为
4. 继承：复用现有代码

### 02设计模式原则

1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，不针对具体实现编程
4. 为交互对象之间的松耦合设计而努力
5. 对扩展开放，对修改关闭

### 03模式

1. 策略模式：
   1. 内容：定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
   2. 其侧重于have a，而不是is a，通过一个对象内含变化的操作，将该变化的操作封装为一个类，通过拥有一个该对象实例来使用该函数，其变化均在该对象中
2. 观察者模式：
   1. 内容：在对象之间定义一对多的传播，这样一来，当一个对象改变状态，依赖他的对象都会
3. 装饰者模式：
   1. 动态的将责任加到对象上面。想要拓展功能，装饰者提供有别与继承的另一种选择
   2. 通过将共同继承自对象的一个类have a一个基类指针，当在装饰者身上针对对象做出动态的调整，从而使再需要对象的时候装饰者可以无缝衔接使用。


### 04模式特点

1. OO设计三个特性：
   1. 复用
   2. 可扩充
   3. 可维护
2. 模式被发现而不是设计
3. 模式不是代码而是设计问题的通用解决方案
4. 将系统中会变化的抽取出来进行封装
5. 重新认识面向对象
   1. 理解隔离变化 
      1. 从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小 
   2. 各司其职
      1. 从微观层面来看，面向对象的方式更强调各个类的“责任” 
      2. 由于需求变化导致的新增类型不应该影响原来类型的实现—— 是所谓各负其责
   3.  对象是什么？ 
      1. 从语言实现层面来看，对象封装了代码和数据。
      2. 从规格层面讲，对象是一系列可被使用的公共接口。
      3. 从概念层面讲，对象是某种拥有责任的抽象。
6. 面向对象设计原则 1
   1. 依赖倒置原则（DIP）
      1. 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
      2.  抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于 抽象(稳定)
   2. 开放封闭原则（OCP） 
      1. 对扩展开放，对更改封闭。 
      2. 类模块应该是可扩展的，但是不可修改。
   3. 单一职责原则（SRP）
      1.  一个类应该仅有一个引起它变化的原因。
      2. 变化的方向隐含着类的责任。
   4. Liskov 替换原则（LSP） 
      1. 子类必须能够替换它们的基类(IS-A)。 
      2. 继承表达类型抽象
   5. 接口隔离原则（ISP） 
      1. 不应该强迫客户程序依赖它们不用的方法。 
      2. 接口应该小而完备
   6. 优先使用对象组合，而不是类继承 
      1. 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 
      2. 继承在某种程度上破坏了封装性，子类父类耦合度高。
      3. 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
   7. 封装变化点 
      1. 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合。
   8. 针对接口编程，而不是针对实现编程 
      1. 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
      2. 客户程序无需获知对象的具体类型，只需要知道对象所具有的 口。 
      3. 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。
7. 三个技巧
   1. 设计习语 Design Idioms • Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 
   2.  设计模式 Design Patterns • Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 
   3.  架构模式 Architectural Patterns • Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关 系的规则。

### 05总览

1. 思维

   1. 底层思维：向下，如何把握机器底层 从微观理解对象构造
      1.  • 语言构造
      2.  • 编译转换 
      3. • 内存模型 
      4. • 运行时机制
   2. 抽象思维：向上，如何将我们的周围 世界抽象为程序代码 
      1.  面向对象 
      2. 组件封装 
      3. 设计模式 
      4. 架构模式

2. 常用解决复杂性思维：

   1. 分解 
      1. 人们面对复杂性有一个常见的做法：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题。
   2.  抽象 •
      1. 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。

3. 模式分类:

   1. 从目的来看：
      1.  • 创建型（Creational）模式：将对象的部分创建工作延迟到子 类或者其他对象，从而应对需求变化为对象创建时具体类型实 现引来的冲击。
      2.  • 结构型（Structural）模式：通过类继承或者对象组合获得更灵 活的结构，从而应对需求变化为对象的结构带来的冲击。
      3.  •行为型（Behavioral）模式：通过类继承或者对象组合来划分 类与对象间的职责，从而应对需求变化为多个交互的对象带来 的冲击。 
   2. 从范围来看：
      1.  类模式处理类与子类的静态关系。
      2.  对象模式处理对象间的动态关系。

   ### 06变化来源

   1. 变化
      1. 客户需求的变化 •
      2.  技术平台的变化 • 
      3. 开发团队的变化 • 
      4. 市场环境的变化
   2. 
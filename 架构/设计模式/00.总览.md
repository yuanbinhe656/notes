# 设计模式基础

1. 抽象

2. 封装：隐藏内部实现

3. 多态：改写对象行为

4. 继承：复用现有代码

5. 抽象思维

    1. 本质：强调对象的本质属性，提炼共性，共性封装

    2. 耦合

        1. 两个模块相互依赖，修改一个，另一个也要修改

    3. 解耦合：

        1. 切换两个模块的依赖关系

    4. 方法：

        1. 分解法：把一个复杂的事物分解成若干简单事物
        2. 抽象法：从每个简单的事物中，抽象出本质的内容封装起来

    5. 目的

        1. 设计原则：
            1. 减少代码的重复性
            2. 方便代码的扩展性
            3. 将==稳定==的模块单独定义

        2. 抽象思维的检验:
            1. 如何检验某种抽象是否做的不错呢?:
                1. 项目需求如果发生更改，不更改现有的代码，通过增加新代码应对需求变更。
                    1. 继承特性，一般用于表达两种意思: 
                        1.  抽象机制: 抽出本质的、共性的内容放到基类中;
                        2. 可重用机制: 基类中的一些内容，直接拿过

                2. 类中内容太多时，就要对类进行拆分，不要把毫不相关的内容写到一个类中
                    1. 面向对象程序设计原则之一: 单一职责原则一一一个类只干好一件事，承担好一种责任，不然就会牵扯太多。


​        

# 设计模式原则

1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，不针对具体实现编程
4. 为交互对象之间的松耦合设计而努力

## 开闭原则

1. 解释：对扩展开放，对修改关闭   —– 增加新功能时，不应该通过修改已经存在的代码来进行，而是应该通过拓展代码（如增加新的类，增加新成员函数）来进行

    ## 依赖倒置原则

### 03模式

1. 策略模式：
   1. 内容：定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
   2. 其侧重于have a，而不是is a，通过一个对象内含变化的操作，将该变化的操作封装为一个类，通过拥有一个该对象实例来使用该函数，其变化均在该对象中
2. 观察者模式：
   1. 内容：在对象之间定义一对多的传播，这样一来，当一个对象改变状态，依赖他的对象都会
3. 装饰者模式：
   1. 动态的将责任加到对象上面。想要拓展功能，装饰者提供有别与继承的另一种选择
   2. 通过将共同继承自对象的一个类have a一个基类指针，当在装饰者身上针对对象做出动态的调整，从而使再需要对象的时候装饰者可以无缝衔接使用。


### 04模式特点

1. OO设计三个特性：
   1. 复用
   2. 可扩充
   3. 可维护
2. 模式被发现而不是设计
3. 模式不是代码而是设计问题的通用解决方案
4. 将系统中会变化的抽取出来进行封装
5. 重新认识面向对象
   1. 理解隔离变化 
      1. 从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小 
   2. 各司其职
      1. 从微观层面来看，面向对象的方式更强调各个类的“责任” 
      2. 由于需求变化导致的新增类型不应该影响原来类型的实现—— 是所谓各负其责
   3.  对象是什么？ 
      1. 从语言实现层面来看，对象封装了代码和数据。
      2. 从规格层面讲，对象是一系列可被使用的公共接口。
      3. 从概念层面讲，对象是某种拥有责任的抽象。
6. 面向对象设计原则 1
   1. 依赖倒置原则（DIP）
      1. 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
      2.  抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于 抽象(稳定)
   2. 开放封闭原则（OCP） 
      1. 对扩展开放，对更改封闭。 
      2. 类模块应该是可扩展的，但是不可修改。
   3. 单一职责原则（SRP）
      1.  一个类应该仅有一个引起它变化的原因。
      2. 变化的方向隐含着类的责任。
   4. Liskov 替换原则（LSP） 
      1. 子类必须能够替换它们的基类(IS-A)。 
      2. 继承表达类型抽象
   5. 接口隔离原则（ISP） 
      1. 不应该强迫客户程序依赖它们不用的方法。 
      2. 接口应该小而完备
   6. 优先使用对象组合，而不是类继承 
      1. 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。 
      2. 继承在某种程度上破坏了封装性，子类父类耦合度高。
      3. 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
   7. 封装变化点 
      1. 使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合。
   8. 针对接口编程，而不是针对实现编程 
      1. 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
      2. 客户程序无需获知对象的具体类型，只需要知道对象所具有的 口。 
      3. 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。
7. 三个技巧
   1. 设计习语 Design Idioms • Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。 
   2.  设计模式 Design Patterns • Design Patterns主要描述的是“类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。 
   3.  架构模式 Architectural Patterns • Architectural Patterns描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关 系的规则。

### 05总览

1. 思维

   1. 底层思维：向下，如何把握机器底层 从微观理解对象构造
      1.  • 语言构造
      2.  • 编译转换 
      3. • 内存模型 
      4. • 运行时机制
   2. 抽象思维：向上，如何将我们的周围 世界抽象为程序代码 
      1.  面向对象 
      2. 组件封装 
      3. 设计模式 
      4. 架构模式

2. 常用解决复杂性思维：

   1. 分解 
      1. 人们面对复杂性有一个常见的做法：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题。
   2.  抽象 •
      1. 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。

3. 模式分类:

   1. 从目的来看：
      1.  创建型（Creational）模式：把对象的创建和使用相分离（解耦），取代传统对象创建方式可能导致的代码修改和维护上的问题。
          1.  比如若new一个对象，若需要修改对象的构造函数，则所有new的地方都需要修改，但若使用一个接口，则只需要修改接口中的内容即可
      2.  结构型（Structural）模式：关注对象之间的关系。设计如何组合各种对象以便获取更加灵活的结构。通过继承以及更多关系的组合来获得更加灵活的结构  ==类和类，对象和对象==
      3.  行为型（Behavioral）模式：关注对象的行为或者交互方面的内容。主要设计算法和对象之间的职责分配。通过使用对象组合，行为型模式可以描述一组对象如何来完成一个整体任务  ==对象和对象==
   2. 从范围来看：
      1.  类模式处理类与子类的静态关系。
      2.  对象模式处理对象间的动态关系。
   
   ### 06变化来源
   
   1. 变化
      1. 客户需求的变化 •
      2.  技术平台的变化 • 
      3. 开发团队的变化 • 
      4. 市场环境的变化
   2. 

## 相关定义区别

### 高层组件和底层组件

1. **高层组件**：通常是更抽象、更泛化的组件，具有较高的层次。这些组件可能是对系统的整体控制或某个特定功能的整合。它们可能更接近系统的用户界面或业务逻辑层，提供了对系统更高层次的抽象，封装了更复杂的操作或逻辑，使得更低层次的组件能够以更简单的方式与其交互。

2. **底层组件**：与高层组件相对，底层组件更接近底层系统、更具体化和更细粒度。这些组件可能是提供基础功能、执行基本操作或处理特定细节的组件。它们为高层组件提供支持和服务，通常更接近系统的基础设施、数据访问或底层算法等方面

3. 关系

    1. 高层组件更抽象，底层组件更具体
    2. 底层组件可能轻微的依赖高层组件（如子类依赖父类的结构），但在使用时，应该是父类依赖子类，父类定义抽象，同时调用抽象，子类实现抽象

4. 系统

    1. 底层组件是基础，高层组件是上层应用

5. 继承

    1. 父类更抽象，因此是高层组件

    2. 子类更加具体，是底层组件

    3. 子类的new实现依赖父类，但父类的方法应该依赖子类的具体实现，如模板方法。符合依赖倒置

        1. **高层模块不应该依赖于低层模块，它们都应该依赖于抽象。**

        2. **抽象不应该依赖于具体实现，具体实现应该依赖于抽象。**

        3. 对于模板方法来说，高层组件（父类），依赖高层组件定义的步骤抽象；底层组件的具体实现，同样依赖于高层组件定义的步骤抽象。他们都是依赖抽象，因此是依赖倒置

        4. 依赖倒置原则是面向对象设计原则之一，它强调的是一种更灵活的依赖关系的建立，其中高层模块不依赖于低层模块的具体实现，而是依赖于抽象。这个原则并不是指父类直接依赖于子类的实现，而是高层模块（比如父类）依赖于抽象而非具体的实现。

            在模板方法模式中，父类作为高层模块，定义了一个模板方法（即算法的骨架），其中的某些步骤通过抽象方法或钩子方法留给子类去实现。这确实让父类在某种程度上依赖于子类的具体实现，但更准确地说，父类是依赖于抽象方法来定义算法的步骤和骨架。

            在依赖倒置原则中，高层模块应该依赖于抽象，而不是依赖于具体的实现。这意味着父类定义了算法的整体流程，但它不依赖于子类的具体执行方式或执行流程。相反，子类通过实现父类所定义的抽象方法，实现了算法中特定步骤的具体逻辑。因此，虽然父类需要子类提供具体实现，但它依赖的是抽象的方法而非具体的子类。

            换句话说，依赖倒置原则强调了高层模块和低层模块之间的松耦合，通过抽象来定义接口和规范，让高层模块不关心底层模块的具体实现细节。这种设计方式使得系统更加灵活、可扩展，同时降低了模块之间的耦合性。

### 钩子方法

1. 定义：子类勾住父类，从而反向控制父类的行为
2. 它允许在父类中定义算法的框架（或骨架），并允许子类根据需要重写或扩展特定的步骤。这些被子类重写的方法通常被称为“钩子”，因为它们允许子类“挂钩”到算法的特定点上。
3. 相当于==子类控制父类的步骤==，一般用于模板方法中
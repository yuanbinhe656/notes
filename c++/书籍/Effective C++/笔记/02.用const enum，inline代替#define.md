1. **#define存在的问题**

   1. #define ASPECT_RATIO 1.653
   2. 其是由预编译器进行处理的，当预编译器处理后，将会用其值全部代替，当编译器进行生成时，由于缺乏宏的记号表（记录参数），对于编译错误难以排查
   3. 对于跨文件使用宏，其错误难以排查
   4. 无封装，对于专属作用域无能为力

2. **用const替换#define。**

   1. const double AspectRatio = 1.653;

   2. ==一般常量==均存储在头文件中，以便被用户所访问

   3. 对于常量指针来说，不仅其指针所指对象不能改变，该指针也不能指向其他对象，因此必须声明为指向常量的常指针

      1. 常指针：指向一个对象，该对象的值不能改变；const int *p =s；
      2. 指针常量：指仅向一个对象，不能指向其他对象 int * const p =s；
      3. 指向常量的常指针：const int *const p=s；

   4. 类中的常量

      1. 对于一个类的专属常量，由于其有作用域，因此需要将其作用域进行限定
      2. 必须保证该文件中仅有一个该名字的常量实体
      3. class GamePlayer{
             static const int numT = 5;
         }
      4. 需要常量的地址时，或者编译器需要还需要定义式，就需要在类外再进行一次定义，对于上式来说，不需要对其进行赋值，已赋值过
      5. 缺点：当class在编译期间便需要一个常量时，有的编译器无法在类中进行const常量定义

3. **用enum代替**

   1. 枚举，用于类中，取其地址不合法，类似于#define，更好的隐私性，防止别人进行获取
   2. 节省内存

4. **用inline代替**

   1. 对于类似函数的宏，最好改用inline函数代替，例如：

   2. ​    

      ```c++
      #define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
      template<typename T>
      
      inline void callWithMax(const T& a, const T& b){
          f(a > b ? a : b);
      }
      ```

5. **总结**：

   + 对于单纯的常量，最好用const和enums替换#define
   +  对于形似函数的宏，最好改用inline函数替换#define

   

   
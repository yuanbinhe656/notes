# 条款31：将文件间的编译依存关系降至最低
--------------------

**1.什么是class接口，什么是class实现细目？**<br>
有两种说话，但是大致意思差不太多：<br>
一、成员函数的声明部分是接口，成员变量和成员函数的定义部分是实现。<br>
二、公有成员变量、公有函数、友元函数、友元类是类的接口，私有成员变量、私有函数是类的具体实现部分。

**2.什么是编译依存关系？**<br>
如果编译器没有取得其实现代码所用到的class定义式，这样的定义式通常由#include指示符提供，所以该类的定义文件的最上方很可能存在这样的东西：
```
#include <string>
#include "date.h"
#include "address.h"
```
这么一来便是在该类的定义文件和其含入文件之间形成了一种编译依赖关系。如果这些头文件中有任何一个被改变，或这些头文件所依赖的其它头文件有任何改变，那么每一个含入该class的文件就得重新编译，任何使用该class的文件也必须重新编译。

**3.以“声明的依存性”替换“定义的依存性”。**<br>
编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略。

**4.设计策略。**<br>
(1)如果使用object reference或object pointers可以完成任务，就不要使用objects。
(2)如果能够，尽量以class声明式替换class定义式。
(3)为声明式和定义式提供不同的头文件。

## 请记住：
* 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。
* 程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。

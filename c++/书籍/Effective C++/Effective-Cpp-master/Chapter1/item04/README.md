# 条款04：确定对象被使用之前已先被初始化

**1.永远在使用对象之前先将它初始化。**<br>
对于无任何成员的内置类型，必须手工完成此事。<br>
对于内置类型以外的任何其他东西，初始化责任落在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。需要主要的是，不要混淆了赋值和初始化。

**2.赋值与初始化的区别。**<br>
基于赋值的构造函数，首先调用构造函数的成员变量的初值，然后立即再对它们赋予新值。成员初值列针对各个成员变量而设的实参，被拿去作为各成员变量之构造函数的实参。<br>
对大多数类型而言，比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的。<br>
有些情况下即使面对的成员变量属于内置类型（那么其初始化与赋值的成本相同），也一定得使用初值列。比如，如果成员变量是const或references，它们一定需要初值，不能被赋值。

**3.成员初始化次序。**<br>
base classes更早于其derived classes被初始化，而class的成员变量总是以声明次序被初始化，即使它们在成员初值列中以不同的次序出现，也不会有任何影响。

**4.static对象，local static对象，non-local static对象，编译单元。**<br>
所谓static对象，其寿命从被构造出来直到程序结束为止。这种对象包括global对象、定义于namespace作用域内的对象、在classes内、在函数内、以及在file作用域内被声明为static的对象。<br>
函数内的static对象成为local static对象，其他static对象称为non-local static对象。<br>
程序结束时static对象会被自动销毁，也就是它们的析构函数会在main()结束时被自动调用。<br>
所谓编译单元，是指产出单一目标文件的那些源代码，基本上它是单一源码文件加上其所含入的头文件。

**5.消除不同的编译单元内的non-local static对象初始化相对次序不明确问题。**<br>
将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这是因为，C++保证函数内的local static对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化。

**6.避免在对象初始化之前过早地使用它们。**<br>
请记住三件事：<br>
第一，手工初始化内置型non-member对象。<br>
第二，使用成员初值列对付对象的所有成分。<br>
第三，在“初始化次序不确定性”氛围下加强你的设计。

## 请记住：
* 为内置型对象进行手工初始化，因为C++不保证初始化它们。
* 构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。
* 为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。

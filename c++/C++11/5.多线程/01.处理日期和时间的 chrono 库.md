C++11 中提供了日期和时间相关的库 chrono，通过 chrono 库可以很方便地处理日期和时间，为程序的开发提供了便利。chrono 库主要包含三种类型的类：`时间间隔duration`、`时钟clocks`、`时间点time point`。

# 1\. 时间间隔 duration

## 1.1 常用类成员

`duration表示一段时间间隔`，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。duration 的原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;chrono&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rep</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> duration;</span><br></pre></td></tr></tbody></table>

- `Rep`：这是一个数值类型，表示时钟数（周期）的类型（默认为整形）。若 `Rep` 是浮点数，则 `duration` 能使用小数描述时钟周期的数目。
  
- `Period`：表示时钟的周期，它的原型如下：
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;ratio&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    std::<span class="type">intmax_t</span> Num,</span><br><span class="line">    std::<span class="type">intmax_t</span> Denom = <span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></tbody></table>
    
    `ratio` 类表示`每个时钟周期的秒数`，其中第一个模板参数 `Num代表分子`，`Denom代表分母`，该分母值默认为 1，因此，`ratio代表的是一个分子除以分母的数值`，比如：ratio<2> 代表一个时钟周期是 2 秒，ratio<60 > 代表一分钟，ratio<60\*60 > 代表一个小时，ratio<60\*60\*24 > 代表一天。而 ratio<1,1000 > 代表的是 1/1000 秒，也就是 1 毫秒，ratio<1,1000000 > 代表一微秒，ratio<1,1000000000 > 代表一纳秒。
    
    > 为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于 chrono 命名空间下，定义如下：
    
    | 类型                                | 定义                                                         |
    | :---------------------------------- | :----------------------------------------------------------- |
    | 纳秒：**std::chrono::nanoseconds**  | duration<Rep\*/\* 至少 64 位的有符号整数类型 \*/\*, [std::nano](http://zh.cppreference.com/w/cpp/numeric/ratio/ratio)\> |
    | 微秒：**std::chrono::microseconds** | duration<Rep\*/\* 至少 55 位的有符号整数类型 \*/\*, [std::micro](http://zh.cppreference.com/w/cpp/numeric/ratio/ratio)\> |
    | 毫秒：**std::chrono::milliseconds** | duration<Rep\*/\* 至少 45 位的有符号整数类型 \*/\*, [std::milli](http://zh.cppreference.com/w/cpp/numeric/ratio/ratio)\> |
    | 秒： **std::chrono::seconds**       | duration<Rep\*/\* 至少 35 位的有符号整数类型 \*/\*>          |
    | 分钟：**std::chrono::minutes**      | duration<Rep\*/\* 至少 29 位的有符号整数类型 \*/\*, [std::ratio](http://zh.cppreference.com/w/cpp/numeric/ratio/ratio)<60>> |
    | 小时：**std::chrono::hours**        | duration<Rep\*/\* 至少 23 位的有符号整数类型 \*/\*, [std::ratio](http://zh.cppreference.com/w/cpp/numeric/ratio/ratio)<3600>> |
    
    注意：到 `hours` 为止的每个预定义时长类型至少涵盖 ±292 年的范围。
    

> duration 类的构造函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 拷贝构造函数</span></span><br><span class="line"><span class="built_in">duration</span>( <span class="type">const</span> duration&amp; ) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 2. 通过指定时钟周期的类型来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> Rep2&amp; r )</span></span>;</span><br><span class="line"><span class="comment">// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2, <span class="keyword">class</span> Period2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> duration&lt;Rep2,Period2&gt;&amp; d )</span></span>;</span><br></pre></td></tr></tbody></table>

> 为了更加方便的进行 duration 对象之间的操作，类内部进行了操作符重载：

| 操作符重载                                                   | 描述                                    |
| ------------------------------------------------------------ | --------------------------------------- |
| [operator=](https://zh.cppreference.com/w/cpp/chrono/duration/operator%3D) | 赋值内容 (公开成员函数)                 |
| [operator+                                                   |                                         |
| operator-](https://zh.cppreference.com/w/cpp/chrono/duration/operator_arith) | 实现一元 + 和一元 - (公开成员函数)      |
| [operator++                                                  |                                         |
| operator++(int)                                              |                                         |
| operator–                                                    |                                         |
| operator–(int)](https://zh.cppreference.com/w/cpp/chrono/duration/operator_arith2) | 递增或递减周期计数 (公开成员函数)       |
| [operator+=                                                  |                                         |
| operator-=                                                   |                                         |
| operator\*=                                                  |                                         |
| operator/=                                                   |                                         |
| operator%=](https://zh.cppreference.com/w/cpp/chrono/duration/operator_arith3) | 实现二个时长间的复合赋值 (公开成员函数) |

> duration 类还提供了`获取时间间隔的时钟周期数`的方法 count ()，函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> rep <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table>

## 1.2 类的使用

> 通过构造函数构造事件间隔对象示例代码如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">chrono::hours <span class="title">h</span><span class="params">(<span class="number">1</span>)</span></span>;                          <span class="comment">// 一小时</span></span><br><span class="line">    chrono::milliseconds ms{ <span class="number">3</span> };                <span class="comment">// 3 毫秒</span></span><br><span class="line">    chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">1000</span>&gt;&gt; <span class="built_in">ks</span>(<span class="number">3</span>);    <span class="comment">// 3000 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// chrono::duration&lt;int, ratio&lt;1000&gt;&gt; d3(3.5);  // error</span></span><br><span class="line">    <span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">dd</span><span class="params">(<span class="number">6.6</span>)</span></span>;               <span class="comment">// 6.6 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用小数表示时钟周期的次数</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz</span>(<span class="number">3.5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

- `h(1)` 时钟周期为 1 小时，共有 1 个时钟周期，所以 h 表示的时间间隔为 1 小时
- `ms(3)` 时钟周期为 1 毫秒，共有 3 个时钟周期，所以 ms 表示的时间间隔为 3 毫秒
- `ks(3)` 时钟周期为 1000 秒，一共有三个时钟周期，所以 ks 表示的时间间隔为 3000 秒
- `d3(3.5)` 时钟周期为 1000 秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误
- `dd(6.6)` 时钟周期为默认的 1 秒，共有 6.6 个时钟周期，所以 dd 表示的时间间隔为 6.6 秒
- `hz(3.5)` 时钟周期为 1/30 秒，共有 3.5 个时钟周期，所以 hz 表示的时间间隔为 1/30\*3.5 秒

chrono 库中根据 duration 类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（`时钟周期 * 周期次数 = 总的时间间隔`）。

**示例代码如下：**

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::chrono::milliseconds ms{<span class="number">3</span>};         <span class="comment">// 3 毫秒</span></span><br><span class="line">    std::chrono::microseconds us = <span class="number">2</span>*ms;     <span class="comment">// 6000 微秒</span></span><br><span class="line">    <span class="comment">// 时间间隔周期为 1/30 秒</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz</span>(<span class="number">3.5</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt;  <span class="string">"3 ms duration has "</span> &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"6000 us duration has "</span> &lt;&lt; us.<span class="built_in">count</span>() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"3.5 hz duration has "</span> &lt;&lt; hz.<span class="built_in">count</span>() &lt;&lt; <span class="string">" ticks\n"</span>;       </span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

**输出的结果为：**

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> ms duration has <span class="number">3</span> ticks</span><br><span class="line"><span class="number">6000</span> us duration has <span class="number">6000</span> ticks</span><br><span class="line"><span class="number">3.5</span> hz duration has <span class="number">3.5</span> ticks</span><br></pre></td></tr></tbody></table>

- `ms` 时间单位为毫秒，初始化操作 `ms{3}` 表示时间间隔为 `3` 毫秒，一共有 3 个时间周期，每个周期为 1 毫秒
- `us` 时间单位为微秒，初始化操作 `2*ms` 表示时间间隔为 `6000` 微秒，一共有 6000 个时间周期，每个周期为 1 微秒
- `hz` 时间单位为秒，初始化操作 `hz(3.5)` 表示时间间隔为 `1/30*3.5` 秒，一共有 3.5 个时间周期，每个周期为 1/30 秒

由于在 duration 类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">chrono::minutes <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">chrono::seconds <span class="title">t2</span><span class="params">(<span class="number">60</span>)</span></span>;</span><br><span class="line">    chrono::seconds t3 = t1 - t2;</span><br><span class="line">    cout &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; <span class="string">" second"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

程序输出的结果：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">540</span> second</span><br></pre></td></tr></tbody></table>

在上面的测试程序中，t1 代表 10 分钟，t2 代表 60 秒，t3 是 t1 减去 t2，也就是 60\*10-60=540，这个 540 表示的时钟周期，每个时钟周期是 1 秒，因此两个时间间隔之间的差值为 540 秒。

注意事项：duration 的加减运算有一定的规则，当两个 duration 时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有 ratio<x1,y1> 和 ratio<x2,y2 > 两个时钟周期，首先需要求出 x1，x2 的最大公约数 X，然后求出 y1，y2 的最小公倍数 Y，统一之后的时钟周期 ratio 为 ratio<X,Y>。

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">9</span>, <span class="number">7</span>&gt;&gt; <span class="built_in">d1</span>(<span class="number">3</span>);</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">6</span>, <span class="number">5</span>&gt;&gt; <span class="built_in">d2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// d1 和 d2 统一之后的时钟周期</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">3</span>, <span class="number">35</span>&gt;&gt; d3 = d1 - d2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

对于分子 6,、9 最大公约数为 3，对于分母 7、5 最小公倍数为 35，因此推导出的时钟周期为 `ratio<3,35>`

# 2\. 时间点 time point

chrono 库中提供了一个表示时间点的类 `time_point`，该类的定义如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;chrono&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Clock</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration</span><br><span class="line">&gt; <span class="keyword">class</span> time_point;</span><br></pre></td></tr></tbody></table>

它被实现成如同存储一个 `Duration` 类型的自 `Clock` 的纪元起始开始的时间间隔的值，通过这个类最终可以得到时间中的某一个时间点。

- `Clock`：此时间点在此时钟上计量
- `Duration`：用于计量从纪元起时间的 [std::chrono::duration](https://zh.cppreference.com/w/cpp/chrono/duration) 类型

> `time_point` 类的构造函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个以新纪元(epoch，即：1970.1.1)作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数</span></span><br><span class="line"><span class="built_in">time_point</span>();</span><br><span class="line"><span class="comment">// 2. 构造一个对象，表示一个时间点，其中d的持续时间从epoch开始，需要和时钟类一起使用，不能单独使用该构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">time_point</span><span class="params">( <span class="type">const</span> duration&amp; d )</span></span>;</span><br><span class="line"><span class="comment">// 3. 拷贝构造函数，构造与t相同时间点的对象，使用的时候需要指定模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Duration2 &gt;</span></span><br><span class="line"><span class="function"><span class="title">time_point</span><span class="params">( <span class="type">const</span> time_point&lt;Clock,Duration2&gt;&amp; t )</span></span>;</span><br></pre></td></tr></tbody></table>

> 在这个类中除了构造函数还提供了另外一个 `time_since_epoch()` 函数，用来获得 1970 年 1 月 1 日到 time\_point 对象中记录的时间经过的时间间隔（duration），函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">duration <span class="title">time_since_epoch</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table>

> 除此之外，时间点 `time_point` 对象和时间段对象 `duration` 之间还支持直接进行算术运算（即加减运算），时间点对象之间可以进行逻辑运算，具体细节可以参考下面的表格：
>
> 其中 `tp` 和 `tp2` 是 `time_point` 类型的对象， `dtn` 是 `duration` 类型的对象。

|                描述                |    操作     |        返回值        |
| :--------------------------------: | :---------: | :------------------: |
|   复合赋值 (成员函数) operator+=   | `tp += dtn` |       `*this`        |
|  复合赋值 (成员函数)  operator-=   | `tp -= dtn` |       `*this`        |
| 算术运算符 (非成员函数) operator+  | `tp + dtn`  | a `time_point` value |
| 算术运算符 (非成员函数)  operator+ | `dtn + tp`  | a`time_point` value  |
| 算术运算符 (非成员函数) operator-  | `tp - dtn`  | a `time_point` value |
| 算术运算符 (非成员函数) operator-  | `tp - tp2`  |  a`duration` value   |
| 关系操作符 (非成员函数) operator== | `tp == tp2` |    a `bool` value    |
| 关系操作符 (非成员函数) operator!= | `tp != tp2` |    a `bool` value    |
| 关系操作符 (非成员函数) operator<  | `tp < tp2`  |    a `bool` value    |
| 关系操作符 (非成员函数) operator>  | `tp > tp2`  |    a `bool` value    |
| 关系操作符 (非成员函数) operator>= | `tp >= tp2` |    a `bool` value    |
| 关系操作符 (非成员函数) operator<= | `tp <= tp2` |    a `bool` value    |

由于该时间点类经常和下面要介绍的时钟类一起使用，所以在此先不举例，在时钟类的示例代码中会涉及到时间点类的使用，到此为止只需要搞明白时间点类的提供的这几个函数的作用就可以了。

# 3\. 时钟 clocks

chrono 库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：

- `system_clock`：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。
- `steady_clock`：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，**适合用于记录程序耗时**
- `high_resolution_clock`：和时钟类 `steady_clock` 是等价的（是它的别名）。

在这些时钟类的内部有 `time_point`、`duration`、`Rep`、`Period` 等信息，基于这些信息来获取当前时间，以及实现 `time_t` 和 `time_point` 之间的相互转换。

| 时钟类成员类型 | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `rep`          | 表示时钟周期次数的有符号算术类型                             |
| `period`       | 表示时钟计次周期的 [std::ratio](https://zh.cppreference.com/w/cpp/numeric/ratio/ratio) 类型 |
| `duration`     | 时间间隔，可以表示负时长                                     |
| `time_point`   | 表示在当前时钟里边记录的时间点                               |

`在使用chrono提供的时钟类的时候，不需要创建类对象，直接调用类的静态方法就可以得到想要的时间了。`

## 3.1 system\_clock

具体来说，时钟类 `system_clock` 是一个系统范围的实时时钟。`system_clock` 提供了对当前时间点 `time_point` 的访问，将得到时间点转换为 `time_t` 类型的时间对象，就可以基于这个时间对象获取到当前的时间信息了。

> `system_clock` 时钟类在底层源码中的定义如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">system_clock</span> { <span class="comment">// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = ratio&lt;<span class="number">1</span>, <span class="number">10'000'000</span>&gt;; <span class="comment">// 100 nanoseconds</span></span><br><span class="line">    <span class="keyword">using</span> duration                  = chrono::duration&lt;rep, period&gt;;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;system_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>{ <span class="comment">// get current time</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Xtime_get_ticks()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> <span class="type">__time64_t</span> <span class="title">to_time_t</span><span class="params">(<span class="type">const</span> time_point&amp; _Time)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>{ <span class="comment">// convert to __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;seconds&gt;(_Time.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">from_time_t</span><span class="params">(<span class="type">__time64_t</span> _Tm)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>{ <span class="comment">// convert from __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> time_point{seconds{_Tm}};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table>

> 通过以上源码可以了解到在 `system_clock` 类中的一些细节信息：

- `rep`：时钟周期次数是通过整形来记录的 `long long`
- `period`：一个时钟周期是 100 纳秒 `ratio<1, 10'000'000>`
- `duration`：时间间隔为 rep\*period 纳秒 `chrono::duration<rep, period>`
- `time_point`：时间点通过系统时钟做了初始化 `chrono::time_point<system_clock>`，里面记录了新纪元时间点

> 另外还可以看到 `system_clock` 类一共提供了三个静态成员函数：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回表示当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 time_point 时间点类型转换为 std::time_t 类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 std::time_t 类型转换为 time_point 时间点类型</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table>

> 比如，我们要获取当前的系统时间，并且需要将其以能够识别的方式打印出来，示例代码如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间</span></span><br><span class="line">    system_clock::time_point epoch;</span><br><span class="line"></span><br><span class="line">    duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; <span class="built_in">day</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 1天</span></span><br><span class="line">    <span class="function">system_clock::time_point <span class="title">ppt</span><span class="params">(day)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> dday = duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt;;</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 10天</span></span><br><span class="line">    <span class="function">time_point&lt;system_clock, dday&gt; <span class="title">t</span><span class="params">(dday(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统当前时间</span></span><br><span class="line">    system_clock::time_point today = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为time_t时间类型</span></span><br><span class="line">    <span class="type">time_t</span> tm = system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    cout &lt;&lt; <span class="string">"今天的日期是:    "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm1 = system_clock::<span class="built_in">to_time_t</span>(today+day);</span><br><span class="line">    cout &lt;&lt; <span class="string">"明天的日期是:    "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm1);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm2 = system_clock::<span class="built_in">to_time_t</span>(epoch);</span><br><span class="line">    cout &lt;&lt; <span class="string">"新纪元时间:      "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm2);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm3 = system_clock::<span class="built_in">to_time_t</span>(ppt);</span><br><span class="line">    cout &lt;&lt; <span class="string">"新纪元时间+1天:  "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm3);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm4 = system_clock::<span class="built_in">to_time_t</span>(t);</span><br><span class="line">    cout &lt;&lt; <span class="string">"新纪元时间+10天: "</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm4);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

示例代码打印的结果为：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">今天的日期是:    Thu Apr  <span class="number">8</span> <span class="number">11</span>:<span class="number">09</span>:<span class="number">49</span> <span class="number">2021</span></span><br><span class="line">明天的日期是:    Fri Apr  <span class="number">9</span> <span class="number">11</span>:<span class="number">09</span>:<span class="number">49</span> <span class="number">2021</span></span><br><span class="line">新纪元时间:      Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line">新纪元时间+<span class="number">1</span>天:  Fri Jan  <span class="number">2</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line">新纪元时间+<span class="number">10</span>天: Sun Jan <span class="number">11</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br></pre></td></tr></tbody></table>

## 3.2 steady\_clock

如果我们通过时钟不是为了获取当前的系统时间，而是进行程序耗时的时长，此时使用 `syetem_clock` 就不合适了，因为这个时间可以跟随系统的设置发生变化。在 C++11 中提供的时钟类 `steady_clock` 相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。

> `steady_clock` 时钟类在底层源码中的定义如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">steady_clock</span> { <span class="comment">// wraps QueryPerformanceCounter</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = nano;</span><br><span class="line">    <span class="keyword">using</span> duration                  = nanoseconds;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;steady_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get current time</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="comment">// doesn't change after system boot</span></span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Freq = _Query_perf_frequency(); </span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Ctr  = _Query_perf_counter();</span><br><span class="line">        <span class="built_in">static_assert</span>(period::num == <span class="number">1</span>, <span class="string">"This assumes period::num == 1."</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Whole = (_Ctr / _Freq) * period::den;</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Part  = (_Ctr % _Freq) * period::den / _Freq;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Whole + _Part));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table>

> 通过以上源码可以了解到在 `steady_clock` 类中的一些细节信息：

- `rep`：时钟周期次数是通过整形来记录的 `long long`
- `period`：一个时钟周期是 1 纳秒 `nano`
- `duration`：时间间隔为 1 纳秒 `nanoseconds`
- `time_point`：时间点通过系统时钟做了初始化 `chrono::time_point<steady_clock>`

> 另外，在这个类中也提供了一个静态的 now () 方法，用于得到当前的时间点，函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::steady_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table>

> 假设要测试某一段程序的执行效率，可以计算它执行期间消耗的总时长，示例代码如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 获取开始时间点</span></span><br><span class="line">    steady_clock::time_point start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 执行业务流程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"print 1000 stars ...."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    steady_clock::time_point last = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算差值</span></span><br><span class="line">    <span class="keyword">auto</span> dt = last - start;</span><br><span class="line">    cout &lt;&lt; <span class="string">"总共耗时: "</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">"纳秒"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

## 3.3 high\_resolution\_clock

`high_resolution_clock` 提供的时钟精度比 `system_clock` 要高，它也是不可以修改的。在底层源码中，这个类其实是 `steady_clock` 类的别名。

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> high_resolution_clock = steady_clock;</span><br></pre></td></tr></tbody></table>

因此 `high_resolution_clock` 的使用方式和 `steady_clock` 是一样的，在此就不再过多进行赘述了。

# 4\. 转换函数

## 4.1 duration\_cast

`duration_cast` 是 `chrono` 库提供的一个模板函数，这个函数不属于 `duration` 类。通过这个函数可以对 `duration` 类对象内部的时钟周期 `Period`，和周期次数的类型 `Rep` 进行修改，该函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> ToDuration <span class="title">duration_cast</span> <span class="params">(<span class="type">const</span> duration&lt;Rep,Period&gt;&amp; dtn)</span></span>;</span><br></pre></td></tr></tbody></table>

1. 如果是对时钟周期进行转换：源时钟周期必须能够整除目的时钟周期（比如：小时到分钟）。
2. 如果是对时钟周期次数的类型进行转换：低等类型默认可以向高等类型进行转换（比如：int 转 double）。
3. 如果时钟周期和时钟周期次数类型都变了，根据第二点进行推导（也就是看时间周期次数类型）。
4. 以上条件都不满足，那么就需要使用 duration\_cast 进行显示转换。

我们可以修改一下上面测试程序执行时间的代码，在代码中修改 `duration` 对象的属性：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"print 1000 stars ...."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> t1 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数时长：时钟周期纳秒转毫秒，要求 duration_cast</span></span><br><span class="line">    <span class="keyword">auto</span> int_ms = <span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(t2 - t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数时长：不要求 duration_cast</span></span><br><span class="line">    duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; fp_ms = t2 - t1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"f() took "</span> &lt;&lt; fp_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">" ms, "</span></span><br><span class="line">        &lt;&lt; <span class="string">"or "</span> &lt;&lt; int_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">" whole milliseconds\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

示例代码输出的结果：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print <span class="number">1000</span> stars ....</span><br><span class="line">****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************</span><br><span class="line"><span class="built_in">f</span>() took <span class="number">40.2547</span> ms, <span class="keyword">or</span> <span class="number">40</span> whole milliseconds</span><br></pre></td></tr></tbody></table>

## 4.2 time\_point\_cast

`time_point_cast` 也是 `chrono` 库提供的一个模板函数，这个函数不属于 `time_point` 类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期 `Period`，和周期次数的类型 `Rep` 可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换，函数原型如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">time_point&lt;Clock, ToDuration&gt; <span class="title">time_point_cast</span><span class="params">(<span class="type">const</span> time_point&lt;Clock, Duration&gt; &amp;t)</span></span>;</span><br></pre></td></tr></tbody></table>

关于函数的使用，示例代码如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Clock = chrono::high_resolution_clock;</span><br><span class="line"><span class="keyword">using</span> Ms = chrono::milliseconds;</span><br><span class="line"><span class="keyword">using</span> Sec = chrono::seconds;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="keyword">using</span> TimePoint = chrono::time_point&lt;Clock, Duration&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ms</span><span class="params">(<span class="type">const</span> TimePoint&lt;Ms&gt;&amp; time_point)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; time_point.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">TimePoint&lt;Sec&gt; <span class="title">time_point_sec</span><span class="params">(Sec(<span class="number">6</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 无精度损失, 可以进行隐式类型转换</span></span><br><span class="line">    <span class="function">TimePoint&lt;Ms&gt; <span class="title">time_point_ms</span><span class="params">(time_point_sec)</span></span>;</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_ms);    <span class="comment">// 6000 ms</span></span><br><span class="line"></span><br><span class="line">    time_point_ms = <span class="built_in">TimePoint</span>&lt;Ms&gt;(<span class="built_in">Ms</span>(<span class="number">6789</span>));</span><br><span class="line">    <span class="comment">// error，会损失精度，不允许进行隐式的类型转换</span></span><br><span class="line">    <span class="function">TimePoint&lt;Sec&gt; <span class="title">sec</span><span class="params">(time_point_ms)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示类型转换,会损失精度。6789 truncated to 6000</span></span><br><span class="line">    time_point_sec = std::chrono::<span class="built_in">time_point_cast</span>&lt;Sec&gt;(time_point_ms);</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_sec); <span class="comment">// 6000 ms</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

注意事项：关于时间点的转换如果没有没有精度的损失可以直接进行隐式类型转换，如果会损失精度只能通过显示类型转换，也就是调用 time\_point\_cast 函数来完成该操作。
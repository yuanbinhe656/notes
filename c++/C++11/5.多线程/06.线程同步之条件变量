条件变量是 C++11 提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用，C++11 提供了两种条件变量：

- `condition_variable`：需要配合 `std::unique_lock<std::mutex>` 进行 wait 操作，也就是阻塞线程的操作。
- `condition_variable_any`：可以和任意带有 `lock()、unlock()` 语义的 mutex 搭配使用，也就是说有四种：
    - `std::mutex`：独占的非递归互斥锁
    - `std::timed_mutex`：带超时的独占非递归互斥锁
    - `std::recursive_mutex`：不带超时功能的递归互斥锁
    - `std::recursive_timed_mutex`：带超时的递归互斥锁

条件变量通常用于生产者和消费者模型，大致使用过程如下：

1. 拥有条件变量的线程获取互斥量
2. 循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行
    - 产品的数量达到上限，生产者阻塞，否则生产者一直生产。。。
    - 产品的数量为零，消费者阻塞，否则消费者一直消费。。。
3. 条件满足之后，可以调用 `notify_one()` 或者 `notify_all()` 唤醒一个或者所有被阻塞的线程
    - 由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产。。。
    - 由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费。。。

# 1\. condition\_variable

## 1.1 成员函数

`condition_variable` 的成员函数主要分为两部分：`线程等待（阻塞）函数` 和`线程通知（唤醒）函数`，这些函数被定义于头文件 `<condition_variable>`。

- **等待函数**
  
    调用 `wait()` 函数的线程会被阻塞
    
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
    - 函数①：调用该函数的线程直接被阻塞
      
    - 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数
      
        - `该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数`
        - `表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行`
    - 独占的互斥锁对象不能直接传递给 `wait()` 函数，需要通过模板类 `unique_lock` 进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。
      
        | 公共成员函数                                                 | 说明                                                         |
        | ------------------------------------------------------------ | ------------------------------------------------------------ |
        | [lock](https://zh.cppreference.com/w/cpp/thread/unique_lock/lock) | 锁定关联的互斥锁                                             |
        | [try\_lock](https://zh.cppreference.com/w/cpp/thread/unique_lock/try_lock) | 尝试锁定关联的互斥锁，若无法锁定，函数直接返回               |
        | [try\_lock\_for](https://zh.cppreference.com/w/cpp/thread/unique_lock/try_lock_for) | 试图锁定关联的可定时锁定互斥锁，若互斥锁在给定时长中仍不能被锁定，函数返回 |
        | [try\_lock\_until](https://zh.cppreference.com/w/cpp/thread/unique_lock/try_lock_until) | 试图锁定关联的可定时锁定互斥锁，若互斥锁在给定的时间点后仍不能被锁定，函数返回 |
        | [unlock](https://zh.cppreference.com/w/cpp/thread/unique_lock/unlock) | 将互斥锁解锁                                                 |
        
    - `如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行`（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。
      
    
    `wait_for()` 函数和 `wait()` 的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。
    
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
    `wait_until()` 函数和 `wait_for()` 的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。
    
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
- **通知函数**
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table>
    
    - `notify_one()`：唤醒一个被当前条件变量阻塞的线程
    - `notify_all()`：唤醒全部被当前条件变量阻塞的线程

## [](https://subingwen.cn/cpp/condition/#1-2-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B "1.2 生产者和消费者模型")1.2 生产者和消费者模型

我们可以使用条件变量来实现一个同步队列，这个队列作为生产者线程和消费者线程的共享资源，示例代码如下：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) {}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 判断任务队列是不是已经满了</span></span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">size</span>() == m_maxSize)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"任务队列已满, 请耐心等待..."</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 阻塞线程</span></span><br><span class="line">            m_notFull.<span class="built_in">wait</span>(locker);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" 被生产"</span> &lt;&lt; endl; </span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; <span class="string">"任务队列已空，请耐心等待。。。"</span> &lt;&lt; endl;</span><br><span class="line">            m_notEmpty.<span class="built_in">wait</span>(locker);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" 被消费"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i+<span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

条件变量 `condition_variable` 类的 `wait()` 还有一个重载的方法，`可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足，如果满足条件（布尔值为true），则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；如果不满足条件（布尔值为false），当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。`

上面示例程序中的 `put()`、`take()` 函数可以做如下修改：

- **put () 函数**
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">    m_notFull.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" 被生产"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 通知消费者去消费</span></span><br><span class="line">    m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>
    
- **take () 函数**
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_notEmpty.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() {</span><br><span class="line">        <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">    <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">    m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 通知生产者去生产</span></span><br><span class="line">    m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" 被消费"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>
    

`修改之后可以发现，程序变得更加精简了，而且执行效率更高了`，因为在这两个函数中的 `while` 循环被删掉了，但是最终的效果是一样的，推荐使用这种方式的 `wait()` 进行线程的阻塞。

# 2\. condition\_variable\_any

## [](https://subingwen.cn/cpp/condition/#2-1-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0 "2.1 成员函数")2.1 成员函数

`condition_variable_any` 的成员函数也是分为两部分：`线程等待（阻塞）函数` 和`线程通知（唤醒）函数`，这些函数被定义于头文件 `<condition_variable>`。

- **等待函数**
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>&gt; <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
    - 函数①：调用该函数的线程直接被阻塞
    - 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数
        - `该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数`
        - `表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行`
    - 可以直接传递给 `wait()` 函数的互斥锁类型有四种，分别是：
        - `std::mutex`、`std::timed_mutex`、`std::recursive_mutex`、`std::recursive_timed_mutex`
    - `如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行`（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。
    
    `wait_for()` 函数和 `wait()` 的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。
    
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
    `wait_until()` 函数和 `wait_for()` 的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。
    
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span> <span class="params">(Lock&amp; lck, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, </span></span></span><br><span class="line"><span class="params"><span class="function">                 Predicate pred)</span></span>;</span><br></pre></td></tr></tbody></table>
    
- **通知函数**
  
    c++
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table>
    
    - `notify_one()`：唤醒一个被当前条件变量阻塞的线程
    - `notify_all()`：唤醒全部被当前条件变量阻塞的线程

## 2.2 生产者和消费者模型

使用条件变量 `condition_variable_any` 同样可以实现上面的生产者和消费者的例子，代码只有个别细节上有所不同：

c++

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">        m_notFull.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() {</span><br><span class="line">            <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" 被生产"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_notEmpty.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() {</span><br><span class="line">            <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">" 被消费"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable_any m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable_any m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);</span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i + <span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

总结：以上介绍的两种条件变量各自有各自的特点，condition\_variable 配合 unique\_lock 使用更灵活一些，可以在在任何时候自由地释放互斥锁，而 condition\_variable\_any 如果和 lock\_guard 一起使用必须要等到其生命周期结束才能将互斥锁释放。但是，condition\_variable\_any 可以和多种互斥锁配合使用，应用场景也更广，而 condition\_variable 只能和独占的非递归互斥锁（mutex）配合使用，有一定的局限性。